
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />  <title>vocabquiz</title>

  <style>
    :root{
      --gameW: 390px;
      --gameH: 700px;
--reviewWordMaxPx: 30px;
      --inventory-row: 84px;
      --inventory-gap: 4px;
      --shop-grid-width: calc(80px * 3 + 8px * 2);
      --shop-modal-extra: 70px;
      /* âœ… ã—ãšãè‰²ï¼ˆJSã§ãƒãƒ¼è‰²ã«åŒæœŸï¼‰ */
      --dropletFill: rgba(255,255,255,.85);
      --dropletAlpha: .78;

      /* =========================
         âœ… ã‚¯ã‚¤ã‚ºè‰²ï¼ˆã“ã“ã§è¨­å®šï¼‰
         æ–‡å­— / æ  / ã‚¿ã‚¤ãƒãƒ¼
      ========================= */
      --quizTextColor: #111;
      --quizFrameColor: #111;
      --quizTimerColor: #111;
      --quizTimerBg: rgba(0,0,0,.12);

      /* âœ… æ­£è§£ãƒœã‚¿ãƒ³ï¼ˆç·‘ï¼šä¸é€æ˜ + ã‚°ãƒ©ãƒ‡ï¼‰ */
      --okA: #2EBC00;
      --okB: #7DEB24;
      --okText: #0b4a1d;

      /* âœ… ä¸æ­£è§£ãƒœã‚¿ãƒ³ï¼ˆèµ¤ï¼šä¸é€æ˜ + ã‚°ãƒ©ãƒ‡ï¼‰ */
      --ngA: #FF81A8;
      --ngB: #FF9BB9;
      --ngText: #5a0000;

      /* é€šå¸¸ãƒœã‚¿ãƒ³ */
      --optBorder: rgba(0,0,0,.18);
      --optBg: rgba(255,255,255,.70);
    }

    html, body{
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
      margin:0; background:#f7f7fb; color:#111;
      transition: background .25s ease;
      touch-action: manipulation;

    }

    /* âœ…èª²é¸æŠç”»é¢ã®ã€Œã•ã‚‰ã«ãã®èƒŒæ™¯ã€ */
    body.lesson-bg{ background:#D16D46; color:#fff; }

    /* âœ…ã‚¯ã‚¤ã‚ºç”»é¢ã®body.bgï¼ˆæŒ‡å®šã©ãŠã‚Šï¼‰ */
    body.quiz-bg{ background:#D1C1BB; color:#111; }

    main{max-width:960px;margin:0 auto;padding:16px}

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input,select,textarea,button{font-size:16px}
    input,select,textarea{padding:10px;border:1px solid #ccc;border-radius:12px;background:#fff}
    button{padding:10px 14px;border:0;border-radius:12px;background:#111;color:#fff;cursor:pointer}
    button.secondary{background:#5b6472}
    button.ghost{background:#fff;color:#111;border:1px solid #ccc}
    .card{background:#fff;border:1px solid #eee;border-radius:14px;padding:14px;margin:12px 0}
    .muted{opacity:.7;font-size:13px}
    .ok{color:#0a7a2f}
    .ng{color:#b00020}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:800px){.grid2{grid-template-columns:1fr}}

    .chara-select{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      display:flex;
      gap:18px;
      align-items:center;
      justify-content:center;
      z-index:5;
    }
    .chara-select button{
      background:none;
      border:0;
      padding:0;
      cursor:pointer;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .chara-select .chara-stack{
      width:110px;
      height:110px;
      display:block;
      border-radius:16px;
      overflow:hidden;
    }
    .chara-layer{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      pointer-events:none;
      user-select:none;
    }
    .chara-stack{
      position:relative;
      width:100%;
      height:100%;
    }
    .chara-select .chara-btn.is-selected::after{
      content:"";
      position:absolute;
      inset:-6px;
      background:
        linear-gradient(#111,#111) left top / 16px 2px no-repeat,
        linear-gradient(#111,#111) left top / 2px 16px no-repeat,
        linear-gradient(#111,#111) right top / 16px 2px no-repeat,
        linear-gradient(#111,#111) right top / 2px 16px no-repeat,
        linear-gradient(#111,#111) left bottom / 16px 2px no-repeat,
        linear-gradient(#111,#111) left bottom / 2px 16px no-repeat,
        linear-gradient(#111,#111) right bottom / 16px 2px no-repeat,
        linear-gradient(#111,#111) right bottom / 2px 16px no-repeat;
      border-radius:16px;
      pointer-events:none;
    }
    .chara-select.single .chara-btn{
      display:none;
    }
    .chara-select.single .chara-btn.is-selected{
      display:flex;
    }


    .student-top{
      display:flex; flex-direction:column; gap:12px;
      max-width:200px;
      margin:60vh auto 0;
      padding:0;
      background:transparent;
      border:0;
      box-shadow:none;

      /* â˜…ã“ã“ã‹ã‚‰è¿½åŠ ï¼šãƒ­ãƒ¼ãƒ‰å®Œäº†ã¾ã§ã¯è¦‹ã›ãªã„ï¼†æŠ¼ã›ãªã„ */
      opacity:0;
      pointer-events:none;
      transform: translateY(4px);
      transition: opacity .25s ease, transform .25s ease;
    }

    /* â˜…ç”»åƒãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã«ä»˜ã‘ã‚‹ã‚¯ãƒ©ã‚¹ */
    .student-top.is-ready{
      opacity:1;
      pointer-events:auto;
      transform: translateY(0);
    }


    .student-top input{
      width:100%;
      font-size:18px;
      padding:20px;
      border-radius:14px;
      text-align:center;
    }
    .student-top button{
      width:100%;
      padding:14px;
      border-radius:14px;
      font-weight:800;
    }
    .student-top input,
    .student-top button{ box-sizing:border-box; }

    .student-top .name-plate{
      position:relative;
      width:100%;
    }
    .student-top .name-plate::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:14px;
      background:#f0f0f0;
      border:1px solid rgba(0,0,0,.12);
      transform: translate(4px, -4px);
      box-shadow:0 10px 18px rgba(0,0,0,.18);
      z-index:0;
    }
    .student-top .name-plate input{
      position:relative;
      z-index:1;
      background:#fff;
    }

    #lessonListBox{ display:flex; flex-direction:column; align-items:center; }

    .lesson-stage{
      position:relative;
      width: min(var(--gameW), calc(100vw - 32px));
      height:min(var(--gameH), calc(100vh - 32px));
      margin: 0 auto;

      background:#FFCCCC;
      border:0;
      border-radius:18px;
      overflow:hidden;
      box-shadow:0 18px 42px rgba(0,0,0,.55);
    }


    .lesson-chara{
      position:absolute;
      left:12px;
      bottom:28px;
      width:112px;
      height:112px;
      display:none;
      align-items:flex-end;
      justify-content:flex-start;
      z-index:6;
      pointer-events:auto;
      cursor:pointer;
    }
    .lesson-chara .chara-stack{
      width:100%;
      height:100%;
    }

   .asaWrap{
      position:absolute;
      right:6px;
      top:-2px;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      z-index:25;
      pointer-events:auto;
    }


   .asaCoinCanvas{
      width: var(--asaCircleSize, 26px);
      height: var(--asaCircleSize, 26px);
      display:block;
      position:relative;
      transform: translateX(75px);
      z-index:26;
      cursor:pointer;
    }

   .asaCircle{
      width: var(--asaCircleSize, 26px);
      height: var(--asaCircleSize, 26px);
      border-radius:999px;
      border:1px solid #9fd7ff;
      background-color: #1b5cc6;
      background-image: url("cart.png");
      background-repeat: no-repeat;
      background-position: center center;
      background-size: 16px 16px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.25);
      transform: translateX(92px);
      z-index:26;
      cursor:pointer;
    }

   .asaPop{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:6px;
      box-shadow:none;
      font-weight:900;
      letter-spacing:.5px;
      pointer-events:none;
      padding:5px 8px;
      min-width:70px;
      --asaBgAlpha: 0.68;
      background: rgba(0,0,0,var(--asaBgAlpha));
      color:#fff;
      border-radius:15px;
      overflow:hidden;
    }


    .asaPop .asaLabel{ display:none; }
    .asaPop .asaValue{
      font-size:18px;
      line-height:1;
      margin-left:auto;
      --asaValueShiftX: -20px;
      --asaValueShiftY: 1px;
      transform: translate(var(--asaValueShiftX), var(--asaValueShiftY));
    }


    .lesson-svg{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:manipulation;
      user-select:none;
    }
    .lesson-hint{ max-width:720px;margin:10px auto 0;opacity:.75; color:#fff }

    /* âœ… å³ä¸‹ï¼šæˆ»ã‚‹â†»ï¼ˆè¨­å®šãƒœã‚¿ãƒ³ã¯æ¶ˆã—ã¦ã“ã‚Œã ã‘ï¼‰ */
    .backFab{
      position:fixed; right:16px; bottom:16px;
      width:54px; height:54px; border-radius:999px;
      background:#111; color:#fff;
      display:none; /* ç”»é¢ã«å¿œã˜ã¦JSã§è¡¨ç¤º */
      align-items:center; justify-content:center;
      box-shadow:0 14px 30px rgba(0,0,0,.25);
      cursor:pointer; user-select:none; z-index:999;
    }
    .backFab span{font-size:24px; line-height:1; transform: translateY(-1px);}

    .gradeFab{
      position:fixed;
      right:16px; bottom:16px;
      transform: translateX(-64px); /* æˆ»ã‚‹â†»ã®å·¦ã«ä¸¦ã¹ã‚‹ */
      display:flex; gap:8px;
      z-index:999;
      user-select:none;
      flex-wrap:wrap;
      max-width: 240px;
      justify-content:flex-end;
      display:none;
    }
    .gbtn{
      width:44px; height:44px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.14);
      color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      cursor:pointer;
      box-shadow:0 10px 22px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
    }
    .gbtn.active{ background:#fff; color:#111; border-color:#fff; }
    .gbtn:disabled{ opacity:.35; cursor:default; box-shadow:none; }

    .modalBack{
      position:fixed; inset:0; background:rgba(0,0,0,.38);
      display:none; align-items:center; justify-content:center;
      z-index:1000; padding:16px;
    }
    .modal{
      width:min(520px, 100%);
      background:#fff; border-radius:18px; border:1px solid #eee;
      box-shadow:0 24px 70px rgba(0,0,0,.35);
      padding:16px;
    }

    /* ===== ã‚¯ã‚¤ã‚ºï¼ˆæ–°UIï¼‰===== */
    .quizStageWrap{
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    .quiz-stage{
      position:relative;
      width: min(var(--gameW), calc(100vw - 32px));
      height:min(var(--gameH), calc(100vh - 32px));
      margin: 0 auto;

      background:
        linear-gradient(0deg, rgba(255,255,255,0.95), rgba(255,255,255,0.75)),
        radial-gradient(1200px 700px at 30% 15%, rgba(255,255,255,0.06), transparent 60%),
        radial-gradient(900px 600px at 80% 40%, rgba(255,255,255,0.04), transparent 65%),
        linear-gradient(160deg, #8f5cff 0%, #6b5fd6 35%, #3a2a6f 100%);

      border: 2px solid var(--quizFrameColor);
      border-radius:18px;
      overflow:hidden;
      box-shadow:0 18px 42px rgba(0,0,0,.55);
      transition: none;
    }

    .quizProgressSvg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      pointer-events:none;
      z-index:1;
    }

    /* âœ… reviewã‚¯ã‚¤ã‚ºç”¨ï¼šç”»é¢ä¸‹ã«æºœã¾ã‚‹é»’ä¸¸ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
    .reviewBallSvg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
      z-index:2; /* wave(1)ã‚ˆã‚Šä¸Š / æ–‡å­—(3)ã‚ˆã‚Šä¸‹ */
    }

    .quizCenterWord{
      position:absolute;
      left:50%; top:70%;
      transform:translate(-50%,-50%);
      width: calc(100% - 40px);
      text-align:center;
      color: var(--quizTextColor);
      font-weight: 950;
      letter-spacing:.2px;
font-size: var(--reviewWordMaxPx);
      line-height:1.15;
      text-shadow: 0 10px 28px rgba(0,0,0,.18);
      user-select:none;
      z-index:3;
    }
/* =========================
   âœ… reviewå•é¡Œï¼šæ”¹è¡Œã—ãªã„ + è‡ªå‹•ç¸®å°ï¼ˆJSã§font-sizeèª¿æ•´ï¼‰
========================= */
.quizCenterWord.oneLine{
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis; /* æœ€ä½ã‚µã‚¤ã‚ºã§ã‚‚åã¾ã‚‰ãªã„æ™‚ã®ä¿é™º */
}

/* âœ… reviewå•é¡Œã®ä¸‹ï¼šä¾‹æ–‡ã‚’å°ã•ãè¡¨ç¤º */
.quizExample{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  width: calc(100% - 40px);
  z-index:3;

  font-weight:400;
  font-size:14px;
  line-height:1.45;
  color: var(--quizTextColor);
  opacity:.70;

  padding:8px 10px;
  border-radius:12px;
  background: rgba(0,0,0,.05);

  /* ä¾‹æ–‡ã¯è¤‡æ•°è¡ŒOK */
  white-space: pre-wrap;
  word-break: break-word;

  /* topã¯JSã§ã€Œå•é¡Œã®ã™ãä¸‹ã€ã«å‹•çš„é…ç½® */
  top: 52%;
  pointer-events:none;
  user-select:none;
}

    .quizOptions{
      position:absolute;
      left:0; right:0;
      bottom:0;
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index:3;
    }

    .optBtn{
      width:100%;
      padding:14px 14px;
      border-radius:16px;
      border: 1px solid var(--optBorder);
      background: var(--optBg);
      color: var(--quizTextColor);
      cursor:pointer;
      text-align:left;
      font-weight:900;
      backdrop-filter: blur(10px);
      -webkit-tap-highlight-color: transparent;
      user-select:none;

      will-change: transform, filter;
      transition: transform .04s linear, filter .06s linear;
      touch-action: manipulation;
    }
    .optBtn:active{ transform: scale(0.99); }
    .optBtn:hover{ border-color: rgba(0,0,0,.30); background: rgba(255,255,255,.78); }
    .optBtn:disabled{ opacity: 1; cursor: default; }

    /* âœ… pendingã¯â€œæš—è»¢ã•ã›ãªã„â€ä¿é™ºï¼ˆä»Šå›JSã§ã¯åŸºæœ¬ä½¿ã‚ãªã„ï¼‰ */
    .optBtn.pending{
      filter: none;
      transform: scale(0.995);
      border-color: rgba(0,0,0,.35);
    }

    .optBtn.goodGreen{
      border-color: var(--okA);
      background: linear-gradient(135deg, var(--okA), var(--okB));
      color: var(--okText);
      filter:none;
    }

    .optBtn.badRed{
      border-color: #c40000;
      background: linear-gradient(135deg, var(--ngA), var(--ngB));
      color: var(--ngText);
      filter:none;
    }

    @keyframes btnShakeFast{
      0%   { transform: translateX(0); }
      15%  { transform: translateX(-7px); }
      30%  { transform: translateX(7px); }
      45%  { transform: translateX(-6px); }
      60%  { transform: translateX(6px); }
      75%  { transform: translateX(-3px); }
      100% { transform: translateX(0); }
    }
    .optBtn.shake{ animation: btnShakeFast .18s linear both; }

    .quizHudHidden{ display:none !important; }

    .qTimer{
      position:fixed;
      right:16px; top:16px;
      width:44px; height:44px;
      z-index:1200;
      pointer-events:none;
      opacity:0.98;
    }
    .qTimer svg{width:100%;height:100%;display:block}
    .qTimer .bg{stroke: var(--quizTimerBg); fill:none; stroke-width:5}
    .qTimer .fg{stroke: var(--quizTimerColor); fill:none; stroke-width:5; stroke-linecap:round}
    .qTimer svg{
      transform: rotate(-90deg) scaleY(-1);
      transform-origin: 50% 50%;
    }

    .stageBadge{
      display:inline-block;
      font-weight:900;
      font-size:12px;
      padding:4px 10px;
      border-radius:999px;
      background:#111;
      color:#fff;
      opacity:.9;
    }

    .stagePop{
      position:absolute;
      z-index:900;
      display:none;
      transform: translate(-50%, 0);
      background:rgba(255,255,255,.96);
      border:1px solid rgba(0,0,0,.12);
      border-radius:14px;
      box-shadow:0 18px 42px rgba(0,0,0,.28);
      padding:10px;
      backdrop-filter: blur(6px);
      min-width: unset;
      width: fit-content;
      max-width: min(92vw, 320px);
    }
    .stagePop .title{
      font-weight:900;
      color:#111;
      font-size:13px;
      margin-bottom:8px;
      text-align:center;
      opacity:.85;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 100%;
    }
    .stagePop .btnRow{
      display:grid;
      gap:10px;
      width: max-content;
      max-width: 100%;
    }
    .stagePop .sbtn{
      width:100%;
      display:flex;
      align-items:center;
      justify-content: flex-start;
      gap:10px;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid #ddd;
      background:#fff;
      color:#111;
      font-weight:950;
      cursor:pointer;
      min-width: 0;
    }
    .stagePop .sbtn:hover{ border-color:#999; }
    .stagePop .sbtn.pre1{ background:#f6f8ff; }
    .stagePop .sbtn.pre2{ background:#f6fff8; }
    .stagePop .sbtn.review{ background:#fff7f6; }
    .stagePop .sbtn:disabled{ opacity:.35; cursor:default; }

    .sbtn .label{
      display:flex;
      align-items:center;
      gap:6px;
      white-space:nowrap;
    }
    .sbtn .icon{
      font-size:18px;
      line-height:1;
      transform: translateY(1px);
    }

    /* âœ… å¾©ç¿’ã‚¢ã‚¤ã‚³ãƒ³ï¼šé»’ã„ç²’5ã¤ã§ã€Œã²ã¨ã¤ã®çµµæ–‡å­—é¢¨ã€ */
    .dots5{
      position:relative;
      width:22px;
      height:22px;
      flex:0 0 22px;
      opacity:.95;
    }
    .dots5 i{
      position:absolute;
      width:6px;
      height:6px;
      border-radius:999px;
      background:#111;
      box-shadow: 0 2px 6px rgba(0,0,0,.18);
    }
    .dots5 i:nth-child(1){ left:24px; top:2px; }
    .dots5 i:nth-child(2){ left:6px; top:5px; }
    .dots5 i:nth-child(3){ left:15px; top:7px; }
    .dots5 i:nth-child(4){ left:22px; top:12px; }
    .dots5 i:nth-child(5){ left:10px; top:14px; }

    .dropletLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:0;
    }
    .droplet{
      position:absolute;
      left:50%;
      top:0%;
      width:46px;
      height:60px;
      transform: translateX(-50%) translateY(var(--fromY, -90px)) scale(0.92);
      opacity:0;
      filter:none;
      will-change: transform, opacity;
      animation: dropletFall var(--dur, 1120ms) cubic-bezier(.22,.84,.44,1) both;
    }
    .droplet::before{
      content:"";
      position:absolute;
      inset:0;
      background: var(--dropletFill);
      opacity: var(--dropletAlpha);
      border: 1px solid rgba(255,255,255,.28);
      border-radius: 999px;
      clip-path: path("M 23 0 C 33 12 44 24 44 37 C 44 52 35 60 23 60 C 11 60 2 52 2 37 C 2 24 13 12 23 0 Z");
      backdrop-filter: blur(6px);
    }
    /* âœ… JSã§æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å‹•ã‹ã•ãªã„ï¼šç´”CSSã§â€œèƒŒæ™¯ã¨ã—ã¦â€è½ã¨ã™ï¼ˆã‚¯ã‚¤ã‚ºã«å¹²æ¸‰ã—ãªã„ï¼‰ */
    @keyframes dropletFall{
      0%   { opacity:0; transform: translateX(-50%) translateY(var(--fromY, -90px)) scale(0.92); }
      10%  { opacity:1; }
      100% { opacity:0; transform: translateX(-50%) translateY(var(--toY, 120%)) scale(1.05); }
    }

    /* âœ… ã‚»ãƒƒã‚·ãƒ§ãƒ³çµæœãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆè¦æ±‚ä»•æ§˜ç‰ˆï¼‰ */
/* âœ… ã‚»ãƒƒã‚·ãƒ§ãƒ³çµæœãƒ¢ãƒ¼ãƒ€ãƒ«ï¼šlowRateã¨åŒã˜ã€Œå†…å®¹ã«åˆã‚ã›ã¦ç¸®ã‚€ã€ */
#sessionBack .modal{
  position:relative;

  /* âœ… ä¸­èº«ã«åˆã‚ã›ã¦ç¸®ã‚€ï¼ˆJSã§æœ€çµ‚ç¢ºå®šï¼‰ */
  width:auto;

  /* âœ… ç”»é¢ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ä¸Šé™ï¼ˆlowRateã¨åŒã˜ï¼‰ */
  max-width:min(92vw, 520px);

  /* âœ… å°ã•ã™ãé˜²æ­¢ï¼ˆlowRateã¨åŒã˜ï¼‰ */
  min-width:260px;

  background:#fff;
  border-radius:18px;
  border:1px solid #eee;
  box-shadow:0 24px 70px rgba(0,0,0,.35);
  padding:18px 16px 56px;
}

    .sessionCenter{
      text-align:center;
      font-weight:950;
      color:#111;
      letter-spacing:.2px;
      line-height:1.25;
      user-select:none;
    }
    .sessionCenter .line1{ font-size:26px; }
    .sessionCenter .line2{ font-size:34px; margin-top:6px; }
    .sessionCenter .line3{ font-size:18px; margin-top:10px; opacity:.95; }

    #sessionTitle{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      flex-wrap:wrap;
      width:100%;
      text-align:center;
    }
    #sessionTitle.is-wrong{
      justify-content:flex-start;
      text-align:left;
    }
    #sessionTitle .sessionAsaGain{
      display:inline-flex;
      align-items:center;
      gap:0px;
      font-weight:900;
      white-space:nowrap;
    }
    #sessionTitle .sessionAsaCoin{
      width:24px;
      height:24px;
      transform:none;
      display:block;
    }

    .sessionCenter .line4{
      font-size:14px;
      margin-top:8px;
      color:#0a7a2f;
      font-weight:900;
    }

    .inventoryBack{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.72);
      z-index:120;
      padding:16px;
      backdrop-filter: blur(4px);
    }
    .inventoryModal{
      width:min(92vw, 520px);
      max-height:80vh;
      overflow:hidden;
      background: rgba(20,20,20,.92);
      color:#fff;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.2);
      box-shadow:0 24px 70px rgba(0,0,0,.45);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .inventoryShowcase{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      margin:0 0 12px;
    }
    .inventoryCharaStage{
      position:relative;
      width:min(300px, 82vw);
      aspect-ratio:1/1;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.2);
      background: rgba(255,255,255,.08);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      margin-top:-6px;
    }
    .inventoryCharaStage .chara-stack{
      width:100%;
      height:100%;
    }
    .inventoryCharaStage .chara-layer{
    }


    .inventoryHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .inventoryHead h3{
      margin:0;
      font-size:16px;
      font-weight:950;
      letter-spacing:.2px;
    }
    .inventoryClose{
      display:none;
    }
    .inventoryGroup{
      margin-top:6px;
      border:1px solid rgba(255,255,255,.15);
      border-radius:14px;
      padding:6px;
      background: rgba(255,255,255,.06);
    }
    #inventoryBody{
      overflow:auto;
      flex:1;
      min-height:0;
      padding-right:4px;
      min-height: calc(var(--inventory-row) * 2.5 + var(--inventory-gap) * 2);
    }
    .inventoryGroup h4{
      margin:0 0 4px;
      font-size:13px;
      font-weight:900;
      opacity:.9;
    }
    .inventoryGrid{
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:var(--inventory-gap);
      grid-auto-rows: 1fr;
    }
    .inventoryItem{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius:12px;
      padding:4px;
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:center;
      text-align:center;
      font-size:0;
      color:#fff;
      cursor:pointer;
      aspect-ratio:1/1;
      height:auto;
    }
    .inventoryItem:hover{
      border-color: rgba(255,255,255,.4);
      background: rgba(255,255,255,.12);
    }
    .inventoryItem.is-placed{
      border-color: rgba(125,235,36,.9);
      box-shadow:0 0 0 2px rgba(125,235,36,.25);
    }
    .inventoryItemThumb{
      position:relative;
      width:100%;
      flex:1;
      min-height:0;
      aspect-ratio:1/1;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      overflow:hidden;
    }
    .inventoryItemThumb img{
      position:absolute;
      width:170%;
      height:170%;
      left:50%;
      top:50%;
      transform: translate(calc(-50% + var(--thumb-x, 0%)), calc(-50% + var(--thumb-y, 0%)));
      object-fit:contain;
    }
    .inventoryItem[data-thumb="full"] .inventoryItemThumb img{
      width:100%;
      height:100%;
      transform: translate(-50%, -50%);
    }

 .shopBack{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      background: rgba(0,0,0,.4);
      z-index:1100;
    }
    .shopModal{
      width:calc(var(--shop-grid-width) + var(--shop-modal-extra));
      background:#111;
      color:#fff;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.15);
      box-shadow:0 22px 60px rgba(0,0,0,.45);
      padding:14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }
    .shopHead{
      display:flex;
      align-items:center;
      width:calc(var(--shop-grid-width) + 20px);
      gap:10px;
    }
    .shopHead h3{
      margin:0;
      font-size:16px;
      font-weight:900;
    }
    .shopTimer{
      margin-left:auto;
      font-size:12px;
      font-weight:900;
      padding:4px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.25);
      letter-spacing:.2px;
    }
    .shopClose{
      width:32px;
      height:32px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.2);
      background: rgba(255,255,255,.08);
      color:#fff;
      cursor:pointer;
      font-size:18px;
      line-height:1;
    }
    .shopGrid{
      display:grid;
      width:var(--shop-grid-width);
      grid-template-columns: repeat(3, 80px);
      gap:8px;
    }
    .shopItem{
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:6px;
      text-align:center;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .shopItemThumb{
      position:relative;
      width:100%;
      aspect-ratio:1/1;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      overflow:hidden;
    }
    .shopItemThumb img{
      position:absolute;
      width:170%;
      height:170%;
      left:50%;
      top:50%;
      transform: translate(calc(-50% + var(--thumb-x, 0%)), calc(-50% + var(--thumb-y, 0%)));
      object-fit:contain;
    }
    .shopItem[data-thumb="full"] .shopItemThumb img{
      width:100%;
      height:100%;
      transform: translate(-50%, -50%);
    }
    .shopPrice{
      font-size:13px;
      font-weight:900;
    }
    .shopEmpty{
      text-align:center;
      font-size:12px;
      opacity:.75;
    }
    .shopPurchaseBack{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      background: rgba(0,0,0,.55);
      z-index:1200;
    }
    .shopPurchaseModal{
      width:min(320px, 92vw);
      background:#111;
      color:#fff;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.15);
      box-shadow:0 24px 60px rgba(0,0,0,.5);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      text-align:center;
    }
    .shopPurchaseThumb{
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .shopPurchaseThumb img{
      width:140px;
      height:140px;
      object-fit:contain;
      border-radius:16px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.15);
    }
    .shopPurchasePrice{
      font-weight:900;
      font-size:14px;
    }
    .shopPurchaseActions{
      display:flex;
      gap:10px;
      justify-content:center;
    }
    .shopPurchaseActions button{
      flex:1;
      padding:10px 12px;
      border-radius:12px;
      border:0;
      font-weight:900;
      cursor:pointer;
    }
    .shopPurchaseBuy{
      background:#22c55e;
      color:#0f172a;
    }
    .shopPurchaseCancel{
      background:#fff;
      color:#111;
    }
    .shopPurchaseStatus{
      font-size:13px;
      font-weight:900;
      opacity:.9;
    }

    .lesson-chara .chara-layer{
    }

    .sessionWrongList{
      margin:14px 0 0;
      padding:0;
      list-style:none;
      max-height:42vh;
      overflow:auto;
      border:1px solid #eee;
      border-radius:14px;
      text-align:left;
    }
    .sessionWrongList li{
      padding:10px 12px;
      border-top:1px solid #eee;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .sessionWrongList li:first-child{ border-top:0; }
    .sessionWrongList .w{ font-weight:950; min-width:120px; }
    .sessionWrongList .m{ opacity:.9; }
    .sessionWrongList .wrongFillWrap{
      display:inline-flex;
      align-items:center;
      gap:4px;
      flex-wrap:wrap;
    }
    .sessionWrongList .wrongFillInput{
      min-width:90px;
      max-width:240px;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid #ddd;
      font-weight:400;
      font-size:14px;
    }

    .sessionWrongList .wrongParen{ color:#d9d9d9; font-weight:900; }
    .sessionWrongList .wrongParenAnswer{ color:#d40000; font-weight:900; }

    .sessionBackBtn{
      position:absolute;
      right:12px;
      bottom:12px;
      padding:10px 14px;
      border-radius:12px;
      border:0;
      background:#111;
      color:#fff;
      font-weight:950;
      cursor:pointer;
    }
    .sessionBackBtn:active{ transform:scale(.99); }

    .line3{
      text-align: center;
      font-weight: 900;
      font-size: 14px;
      color: #111;
      margin-bottom: 8px;
      opacity: 0.85;
    }

/* âœ… ã‚»ãƒƒã‚·ãƒ§ãƒ³çµæœï¼š100%æ™‚ã«è¡¨ç¤ºã™ã‚‹GETã‚¢ã‚¤ãƒ†ãƒ  */
.sessionRewardItem{
  margin-top:10px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:6px;
}

.sessionRewardThumb{
  position:relative;
  width:var(--inventory-row, 84px);
  height:var(--inventory-row, 84px);
  border-radius:12px;
  border:1px solid #ddd;
  background:#f5f5f5;
  overflow:hidden;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}

.sessionRewardThumb img{
  position:absolute;
  width:170%;
  height:170%;
  left:50%;
  top:50%;
  transform: translate(calc(-50% + var(--thumb-x, 0%)), calc(-50% + var(--thumb-y, 0%)));
  object-fit:contain;
  display:block;
}

.sessionRewardItem[data-thumb="full"] .sessionRewardThumb img{
  width:100%;
  height:100%;
  transform: translate(-50%, -50%);
}

.sessionRewardName{
  font-size:14px;
  font-weight:900;
  color:#111;
}


    /* =========================
       âœ… reviewé”æˆ(10%ã”ã¨)ã®é»’ä¸¸
       - åˆæœŸè½ä¸‹ä½ç½®ï¼šãƒ©ãƒ³ãƒ€ãƒ ï¼ˆstartDXï¼‰
       - ç€åœ°ä½ç½®ï¼šæ®µã”ã¨ã«â€œå›ºå®šâ€
       - ç€åœ°å¾Œï¼šå·¦å³ã«â€œã”ãåƒ…ã‹â€
       - ãƒã‚¦ãƒ³ãƒ‰ï¼š0.1pxã ã‘
    ========================= */
    .reviewBall{
      fill:#111;
      opacity:.95;
      pointer-events:none;
      transform-box: fill-box;
      transform-origin: center;
      will-change: transform;
    }
    .reviewBall.drop{
      animation: ballDrop 1.0s cubic-bezier(.22,.84,.44,1) both;
    }
    #reviewBallSvg .reviewBall{
      opacity: 0.2;  /* â†è–„ã• */
    }
    @keyframes ballDrop{
      0%{
        transform: translate(
          calc(var(--landDX, 0px) + var(--startDX, 0px)),
          var(--dropFrom, -140px)
        );
      }
      82%{
        transform: translate(var(--landDX, 0px), 0px);
      }
      90%{
        transform: translate(
          calc(var(--landDX, 0px) + var(--rollMid, 0px)),
          0.1px
        );
      }
      100%{
        transform: translate(
          calc(var(--landDX, 0px) + var(--rollDX, 0px)),
          0px
        );
      }
    }

    /* =========================
       âœ… è¿½åŠ ï¼špre1/pre2ãŒ40%æœªæº€ã®ã¨ãã®lowRateãƒãƒƒãƒ—
       - å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
       - é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ãªã—
       - ã€ŒãŸã¨ãˆã°...ã€ã®ä¸‹ã« 3ã¤ã®ã€Œå˜èª - æ­£è§£ã€ãƒ©ãƒ³ãƒ€ãƒ è¡¨ç¤º
       - å·¦ï¼šé»’ãƒœã‚¿ãƒ³ç™½å­—ã€Œã§ããã†ï¼ğŸ’§ã€ã§ã‚¯ã‚¤ã‚ºé–‹å§‹
       - å³ï¼šã€ŒãŠã¼ãˆã‚‹ğŸ‘€ã€ã¯å¾Œã§è¨­å®šï¼ˆä»Šã¯é–‰ã˜ã‚‹ã ã‘ï¼‰
    ========================= */
/* âœ… è¿½åŠ ï¼šlowRateãƒãƒƒãƒ—ï¼ˆå¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ / é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ãªã—ï¼‰ */
#lowRateBack{
  z-index:1400;
  background: rgba(0,0,0,.42);
}
#lowRateBack .modal{
  position:relative;

  /* âœ… ä¸­èº«ã«åˆã‚ã›ã¦ç¸®ã‚€ï¼ˆJSã§æœ€çµ‚ç¢ºå®šï¼‰ */
  width:auto;

  /* âœ… ç”»é¢ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ä¸Šé™ */
  max-width:min(92vw, 520px);

  /* âœ… å°ã•ã™ãé˜²æ­¢ï¼ˆå¥½ã¿ã§èª¿æ•´OKï¼‰ */
  min-width:260px;

  padding:16px 16px 14px;
  border-radius:18px;
}

    .lrHead{
      font-weight:950;
      font-size:14px;
      opacity:.86;
      text-align:center;
      margin-bottom:10px;
      user-select:none;
      color:#111;
  display:none;
    }
    .lrExampleLabel{
      font-weight:900;
      font-size:14px;
      opacity:.80;
      margin:6px 0 8px;
      user-select:none;
      color:#111;
    }
    .lrList{
      list-style:none;
      padding:0;
      margin:0;
      border:1px solid #eee;
      border-radius:14px;
      overflow:hidden;
      max-height:38vh;
      overflow:auto;
      background:#fff;
    }
    .lrList li{
      padding:10px 12px;
      border-top:1px solid #eee;
      font-weight:900;
      color:#111;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .lrList li:first-child{ border-top:0; }
    .lrList .lrWord{
      min-width:50px;
      opacity:.95;
    }
    .lrList .lrDash{
      opacity:.5;
      flex:0 0 auto;
    }
    .lrList .lrMean{
      opacity:.90;
      font-weight:850;
      word-break:break-word;
    }
#flashBack .flashWord.flashMasked{
  color: transparent;
  background: #c7c7c7;
  border-radius: 0;
}
    .lrBtns{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .lrStart{
      background:#111;
      color:#fff;
      font-weight:950;
      border-radius:14px;
      padding:12px 14px;
    }
    .lrMem{
      background:#fff;
      color:#111;
      font-weight:950;
      border-radius:14px;
      padding:12px 14px;
      border:1px solid #ccc;
    }
    .lrStart:active, .lrMem:active{ transform:scale(.99); }

/* =========================
   âœ… è¿½åŠ ï¼šãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰ï¼ˆãŠã¼ãˆã‚‹ğŸ‘€ï¼‰
   - å·¦ã‚¹ãƒ¯ã‚¤ãƒ—ã§æ¬¡
   - 2ç§’ã§è‡ªå‹•æ¬¡
   - ã‚¹ãƒ©ã‚¤ãƒ‰ã‚¢ãƒ‹ãƒ¡
========================= */
#flashBack{
  align-items:flex-end; /* âœ… è¦æœ›ï¼šä½ç½®ã‚’å°‘ã—ä¸‹ã’ã‚‹ */
  padding:32px 16px 24px;
}
#flashBack{
  z-index:1500; /* lowRate(1400)ã‚ˆã‚Šä¸Š */
  background: rgba(0,0,0,.42);
}

/* âœ… lowRate/session ã¨åŒã˜ï¼šå†…å®¹ã«åˆã‚ã›ã¦ç¸®ã‚€å¹…ï¼ˆJSã§ç¢ºå®šï¼‰ */
#flashBack .flashModal{
  width:auto;                          /* â†ç¸®ã‚€ */
  max-width:min(88vw, 380px);          /* â†ã¯ã¿å‡ºã—é˜²æ­¢ */
  min-width:220px;                      /* â†å°ã•ã™ãé˜²æ­¢ */
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:10px;
}

#flashBack .flashCard{
  width:100%;                          /* â†modalå¹…ã«è¿½å¾“ */
  background:#fff;
  border-radius:18px;
  border:1px solid #eee;
  box-shadow:0 24px 70px rgba(0,0,0,.35);
  padding:12px 16px;
  user-select:none;
  touch-action: none; /* âœ…æ¨ªãƒ‰ãƒ©ãƒƒã‚°ã‚’æœ€å„ªå…ˆï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«/ã‚¸ã‚§ã‚¹ãƒãƒ£ã§ã‚«ã‚¯ã¤ã‹ãªã„ï¼‰ */
  contain: layout paint; /* âœ…å‘¨è¾ºã¸ã®å½±éŸ¿ã‚’æ¸›ã‚‰ã—ã¦å®‰å®š */
  will-change: transform, opacity;
}

#flashBack .flashList{
  display:flex;
  flex-direction:column;
}
#flashBack .flashRow{
  display:flex;
  flex-direction:column;
  gap:6px;
  padding:10px 4px;
}
#flashBack .flashRow:not(:last-child){
  border-bottom:1px dotted rgba(0,0,0,.2);
}
#flashBack .flashRow.is-empty .flashMain,
#flashBack .flashRow.is-empty .flashExampleLine{
  opacity:0;
}
#flashBack .flashMain{
  display:flex;
  align-items:baseline;
  gap:20px;
  min-height:22px;
}
#flashBack .flashMeaning{
  font-weight:950;
  font-size:18px;
  line-height:1.2;
  color:#111;
  word-break:break-word;
}
#flashBack .flashWord{
  font-weight:900;
  font-size:16px;
  line-height:1.2;
  color:#111;
  opacity:.9;
  word-break:break-word;
}
#flashBack .flashPager{
  font-weight:900;
  font-size:13px;
  color:#fff;
  opacity:.92;
  user-select:none;
  text-shadow:0 6px 18px rgba(0,0,0,.35);
}

.flashModeWrap{
  display:flex;
  gap:10px;
  width:100%;
  margin-top:6px;
  justify-content:center;
}
.flashModeBtn{
  flex:1;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:8px;
  border:1px solid #d5d5d5;
  border-radius:14px;
  background:linear-gradient(180deg, #f2f2f2 0%, #e7e7e7 100%);
  color:#111;
  padding:10px 12px;
  font-weight:900;
  text-align:left;
  box-shadow:0 10px 26px rgba(0,0,0,.14);
  transition: background .18s ease, color .18s ease, border-color .18s ease, transform .12s ease;
  cursor:pointer;
  max-width:180px;
  min-height:50px;
}
.flashModeBtn:active{ transform:scale(.99); }
.flashModeBtn .flashModeLabel{
  width:100%;
  text-align:center;
  font-size:16px;
  line-height:1.1;
}



.flashModeBtn.active{
  background:#111;
  border-color:#111;
  color:#fff;
  box-shadow:0 12px 30px rgba(0,0,0,.35);
}
.flashModeBtn.active .flashModeLabel{ opacity:1; }

/* âœ… è¿½åŠ ï¼šãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰ã®ä¾‹æ–‡ï¼ˆreview quizã¨åŒã˜ä»•æ§˜ï¼‰ */
#flashBack .flashExampleLine{
  font-weight:400;
  font-size:14px;
  line-height:1.45;
  color:#111;
  opacity:.70;
  padding:4px 8px;
  border-radius:10px;
  background: rgba(0,0,0,.05);
  white-space: pre-wrap;
  word-break: break-word;
  min-height:16px;
}
#flashBack .flashExampleLine.is-empty{
  background: transparent;
  opacity: 0;
}


/* æ¬¡ã¸ï¼šã‚¹ãƒ©ã‚¤ãƒ‰ï¼ˆå·¦ã¸å‡ºã¦â†’å³ã‹ã‚‰å…¥ã‚‹ï¼‰ */
/* =========================
   âœ… Flashï¼šä¸¡æ–¹å‘ã‚¹ãƒ©ã‚¤ãƒ‰ï¼ˆGPUã§ãªã‚ã‚‰ã‹ï¼‰
========================= */
#flashBack .flashCard{
  /* æ—¢ã«ã‚ã‚‹ will-change ã¯OKã€‚ã‚ˆã‚Šæ»‘ã‚‰ã‹ã«ã™ã‚‹ãŸã‚3DåŒ– */
  transform: translate3d(0,0,0);
  backface-visibility: hidden;
}

@keyframes flashOutLeft{
  0%   { transform: translate3d(var(--flashFromX, 0px),0,0); opacity:1; }
  100% { transform: translate3d(-105%,0,0); opacity:0; }
}
@keyframes flashOutRight{
  0%   { transform: translate3d(var(--flashFromX, 0px),0,0); opacity:1; }
  100% { transform: translate3d(105%,0,0); opacity:0; }
}
@keyframes flashInRight{
  0%   { transform: translate3d(105%,0,0); opacity:0; }
  100% { transform: translate3d(0,0,0); opacity:1; }
}
@keyframes flashInLeft{
  0%   { transform: translate3d(-105%,0,0); opacity:0; }
  100% { transform: translate3d(0,0,0); opacity:1; }
}

/* ã‚¯ãƒ©ã‚¹é©ç”¨ */
.flashOutLeft  { animation: flashOutLeft  .18s cubic-bezier(.22,.84,.44,1) both; }
.flashInRight  { animation: flashInRight  .18s cubic-bezier(.22,.84,.44,1) both; }
.flashOutRight { animation: flashOutRight .18s cubic-bezier(.22,.84,.44,1) both; }
.flashInLeft   { animation: flashInLeft   .18s cubic-bezier(.22,.84,.44,1) both; }


/* ===== TOP ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆ6ã¤ã®èŒ¶è‰²ã„ç‚¹ãã‚‹ãã‚‹ï¼‰ ===== */
.top-loading{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#fff;
  z-index:1200;
  transition:opacity .25s ease;
}

.top-loading.is-hidden{
  opacity:0;
  pointer-events:none;
}

.top-loading-circle{
  position:relative;
  width:72px;
  height:72px;
  animation: topLoadingSpin 1s linear infinite;
  /* å¿µã®ãŸã‚ï¼šå›è»¢è»¸ã‚’ä¸­å¿ƒå›ºå®š */
  transform-origin: 50% 50%;
}

.top-loading-circle span{
  position:absolute;
  left:50%;
  top:50%;
  width:10px;
  height:10px;
  border-radius:50%;
  background:#8b5a2b;
  opacity:.25;

  /* âœ… ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼š
     1) ã¾ãšä¸­å¿ƒã¸ï¼ˆ-50%,-50%ï¼‰
     2) è§’åº¦ã¶ã‚“å›è»¢
     3) åŠå¾„ã¶ã‚“ä¸Šã¸ç§»å‹•ï¼ˆå††å‘¨ã¸ï¼‰ */
  transform: translate(-50%, -50%)
             rotate(calc(60deg * var(--i)))
             translateY(-26px);
}

.top-loading-circle span::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  background:inherit;
  animation: topLoadingDot 1s ease-in-out infinite;
  animation-delay: calc(0.08s * var(--i));
}

@keyframes topLoadingSpin{
  0%{   transform: rotate(0deg); }
  100%{ transform: rotate(360deg); }
}

@keyframes topLoadingDot{
  0%,100%{ transform: scale(.8);   opacity:.3; }
  40%{     transform: scale(1.15); opacity:1; }
}



  </style>
</head>

<body>
<main>
  <section id="studentSec">

    <!-- â˜… TOP ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆ6ã¤ã®èŒ¶è‰²ã„ç‚¹ï¼‰ -->
    <div class="top-loading" id="topLoading">
      <div class="top-loading-circle">
        <span style="--i:0"></span>
        <span style="--i:1"></span>
        <span style="--i:2"></span>
        <span style="--i:3"></span>
        <span style="--i:4"></span>
        <span style="--i:5"></span>
      </div>
    </div>


    <div class="chara-select" id="charaSelect" aria-label="chara chooser"></div>


    <div class="student-top" id="studentTop">
      <div class="name-plate">
        <input id="stuName" placeholder="Enter name" />
      </div>
      <button id="btnStart">ã‚¢ãƒ«ãƒã‚¤ãƒˆã‚’ã¯ã˜ã‚ã‚‹</button>
      <div id="stuStatus" class="muted" style="text-align:center"></div>
    </div>

    <div id="lessonListBox" style="display:none">
      <div class="lesson-stage" id="lessonList">
        <svg class="lesson-svg" id="lessonSvg" aria-label="lesson menu"></svg>

        <div class="lesson-chara" id="lessonChara" aria-hidden="true">
          <div class="chara-stack" id="lessonCharaStack" aria-hidden="true"></div>
        </div>

        <div class="asaWrap">
          <canvas class="asaCoinCanvas" id="asaCoinCanvas" aria-hidden="true"></canvas>
          <div class="asaCircle" id="asaCircle" aria-hidden="true"></div>
          <div class="asaPop" id="asaPop" aria-label="ASA points" title="ãŸã‚ãŸASA" style="display:none">
            <span class="asaLabel">ASA</span>
            <span class="asaValue" id="asaValue">0</span>
          </div>
        </div>
        <!-- âœ… äºˆç¿’å¾©ç¿’é¸æŠãƒãƒƒãƒ—ï¼ˆç¸¦ä¸¦ã³ï¼‰ -->
        <div class="stagePop" id="stagePop" aria-label="stage chooser">
          <div class="title" id="stagePopTitle">èª²</div>
          <div class="btnRow">
            <button class="sbtn pre1"   id="btnStagePre1"   type="button">
              <span class="label">å˜èª1 <span class="icon">ğŸ¥›</span></span>
              <span></span>
            </button>
            <button class="sbtn pre2"   id="btnStagePre2"   type="button">
              <span class="label">å˜èª2 <span class="icon">ğŸ¥›</span></span>
              <span></span>
            </button>
            <button class="sbtn review" id="btnStageReview" type="button">
              <span class="label">å¾©ç¿’</span>
              <span class="dots5" aria-hidden="true"><i></i><i></i><i></i><i></i><i></i></span>
            </button>
          </div>
        </div>
      </div>

      <div class="muted lesson-hint" style="display:none">
        èª²ã‚’æŠ¼ã™ã¨ã‚¯ã‚¤ã‚ºãŒå§‹ã¾ã‚Šã¾ã™ã€‚ï¼ˆå­¦å¹´ã¯å³ä¸‹ã§åˆ‡æ›¿ï¼‰
      </div>
    </div>

    <div id="quizBox" style="display:none; margin: 0 auto; padding-top: 0;">
      <div class="quizHudHidden">
        <span class="muted" id="lessonInfo" style="font-weight:900;opacity:.9"></span>
        <span class="stageBadge" id="stageBadge" style="display:none"></span>
        <div class="muted" id="hint" style="margin-top:8px;display:none"></div>
        <div class="muted" id="quizResult"></div>
        <button id="btnNext" class="secondary">æ¬¡ã®å•é¡Œ</button>
        <button id="btnLessonComplete" class="secondary">ã“ã®æ®µéšã‚’å®Œäº†</button>
        <button id="btnBackLessons" class="ghost">æˆ»ã‚‹</button>
      </div>

      <div class="quizStageWrap">
        <div class="quiz-stage" id="quizStage" aria-label="quiz stage">
          <svg class="quizProgressSvg" id="quizProgressSvg" aria-hidden="true"></svg>

          <!-- âœ… reviewã‚¯ã‚¤ã‚ºï¼šé»’ä¸¸ãŒæºœã¾ã‚‹ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
          <svg class="reviewBallSvg" id="reviewBallSvg" aria-hidden="true"></svg>

          <div class="dropletLayer" id="dropletLayer" aria-hidden="true"></div>
          <div class="quizCenterWord" id="quizWord"></div>
<div class="quizExample" id="quizExample" style="display:none"></div>
          <div class="quizOptions" id="optGrid"></div>
        </div>
      </div>
    </div>
  </section>
</main>

<!-- âœ… å³ä¸‹ï¼šå­¦å¹´ãƒœã‚¿ãƒ³ï¼ˆèª²é¸æŠä¸­ã ã‘è¡¨ç¤ºï¼‰ -->
<div class="gradeFab" id="gradeFab" aria-label="grade selector"></div>

<!-- âœ… å³ä¸‹ï¼šæˆ»ã‚‹â†»ï¼ˆèª²é¸æŠ/ã‚¯ã‚¤ã‚ºã§è¡¨ç¤ºï¼‰ -->
<div class="backFab" id="backFab" title="æˆ»ã‚‹"><span>â†»</span></div>

<!-- âœ… ã‚»ãƒƒã‚·ãƒ§ãƒ³çµæœãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆè¦æ±‚ä»•æ§˜ç‰ˆï¼‰ -->
<div class="modalBack" id="sessionBack" aria-label="session result">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="sessionCenter">
      <div class="line1">çµæœï¼</div>
      <div class="line2" id="sessionPct">--%</div>
<div class="line3" id="sessionTitle">
  <span id="sessionTitleText">é–“é•ãˆãŸã“ã¨ã°</span>
  <span class="sessionAsaGain" id="sessionAsaGain">
    <span class="sessionAsaSign">+</span>
    <span class="sessionAsaValue" id="sessionAsaValue">0</span>
    <canvas class="asaCoinCanvas sessionAsaCoin" id="sessionAsaCoin" aria-hidden="true"></canvas>
  </span>
</div>

      <div class="line4" id="sessionReward" style="display:none"></div>
    </div>

    <ul class="sessionWrongList" id="wrongList"></ul>

    <button id="btnSessionClose" class="sessionBackBtn" type="button">æˆ»ã‚‹</button>
  </div>
</div>

<!-- âœ… æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ ç¢ºèªãƒãƒƒãƒ— -->
<div class="inventoryBack" id="inventoryBack" aria-label="inventory">
  <div class="inventoryModal" role="dialog" aria-modal="true">
    <div class="inventoryHead">
      <h3 aria-hidden="true"></h3>
    </div>
    <div class="inventoryShowcase">
      <div class="inventoryCharaStage" id="inventoryCharaStage">
        <div class="chara-stack" id="inventoryCharaStack" aria-hidden="true"></div>
      </div>
    </div>
    <div class="small" id="inventoryMsg">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
    <div id="inventoryBody"></div>
  </div>
</div>


<div class="shopBack" id="shopBack" aria-label="shop">
  <div class="shopModal" role="dialog" aria-modal="true">
    <div class="shopHead">
      <h3>ã‚·ãƒ§ãƒƒãƒ—</h3>
      <div class="shopTimer" id="shopTimer">ãŠåº—ã®å•†å“ãŒå¤‰ã‚ã‚‹ã¾ã§ --:--</div>
      <button class="shopClose" id="shopClose" type="button">Ã—</button>
    </div>
    <div class="shopGrid" id="shopGrid"></div>
    <div class="shopEmpty" id="shopEmpty">ã‚·ãƒ§ãƒƒãƒ—ã«è¡¨ç¤ºã§ãã‚‹ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>
  </div>
</div>

<div class="shopPurchaseBack" id="shopPurchaseBack" aria-label="shop purchase">
  <div class="shopPurchaseModal" role="dialog" aria-modal="true">
    <div class="shopPurchaseThumb">
      <img id="shopPurchaseImg" alt="è³¼å…¥ã‚¢ã‚¤ãƒ†ãƒ ">
    </div>
    <div class="shopPurchasePrice" id="shopPurchasePrice"></div>
    <div class="shopPurchaseActions" id="shopPurchaseActions">
      <button class="shopPurchaseBuy" id="shopPurchaseBtn" type="button">è³¼å…¥ã™ã‚‹</button>
      <button class="shopPurchaseCancel" id="shopCancelBtn" type="button">ã‚„ã‚ã‚‹</button>
    </div>
    <div class="shopPurchaseStatus" id="shopPurchaseStatus"></div>
  </div>
</div>



<!-- âœ… è¿½åŠ ï¼šlowRateãƒãƒƒãƒ—ï¼ˆå¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ / é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ãªã—ï¼‰ -->
<div class="modalBack" id="lowRateBack" aria-label="low rate hint">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="lrHead" id="lowRateTitle"></div>

    <div class="lrExampleLabel">ãŸã¨ãˆã°...</div>
    <ul class="lrList" id="lowRateList"></ul>

    <div class="lrBtns">
      <button id="btnLowRateStart" class="lrStart" type="button">ã§ããã†ï¼ğŸ¥›</button>
      <button id="btnLowRateMem" class="lrMem" type="button">ãŠã¼ãˆã‚‹ğŸ‘€</button>
    </div>
  </div>
</div>

<div class="qTimer" id="qTimer" style="display:none" aria-label="question timer">
  <svg viewBox="0 0 44 44">
    <circle class="bg" cx="22" cy="22" r="18"></circle>
    <circle class="fg" id="qTimerFg" cx="22" cy="22" r="18"></circle>
  </svg>
</div>


<!-- âœ… è¿½åŠ ï¼šãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰ï¼ˆãŠã¼ãˆã‚‹ğŸ‘€ï¼‰ -->
<div class="modalBack" id="flashBack" aria-label="flash cards">
  <div class="flashModal" role="dialog" aria-modal="true">
    <div class="flashCard" id="flashCard">
      <div class="flashList" id="flashList"></div>
    </div>

    <div class="flashPager" id="flashPager">1/1</div>

    <div class="flashModeWrap" id="flashModeWrap">
      <button class="flashModeBtn" type="button" id="flashModeUnified">
        <div class="flashModeLabel">ã‹ãã™</div>
      </button>
    </div>

  </div>
</div>


<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, get, set, update, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* =========================
   âœ… Firebaseï¼ˆRealtime Databaseï¼‰
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyARne6Jb4ePPe7vbvLryE_P-jZ2umI3LFc",
  authDomain: "kakapo-8d297.firebaseapp.com",
  databaseURL: "https://kakapo-8d297-default-rtdb.firebaseio.com",
  projectId: "kakapo-8d297",
  storageBucket: "kakapo-8d297.firebasestorage.app",
  messagingSenderId: "702767130857",
  appId: "1:702767130857:web:54472c8d5ea09bd3cf6878"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

function delay(ms){
  return new Promise(resolve => setTimeout(resolve, ms));
}
async function dbGet(path, options={}){
  const timeoutMs = Number.isFinite(options.timeoutMs) ? options.timeoutMs : 5000;
  const retries = Number.isFinite(options.retries) ? options.retries : 2;

  let lastError = null;
  for (let attempt = 0; attempt <= retries; attempt++){
    try{
      const snap = await Promise.race([
        get(ref(db, path)),
        new Promise((_, reject)=> setTimeout(()=> reject(new Error("db_get_timeout")), timeoutMs))
      ]);
      return snap.exists() ? snap.val() : null;
    }catch(e){
      lastError = e;
      if (attempt < retries){
        await delay(200 + (attempt * 200));
      }
    }
  }

  throw lastError || new Error("db_get_failed");
}
async function dbSet(path, value){
  await set(ref(db, path), value);
}
async function dbUpdate(path, patch){
  await update(ref(db, path), patch);
}

function nowTs(){ return Date.now(); }

const STUDENT = { studentKey: null };

const P = {
  students: (studentKey)=> `students/${studentKey}`,
  wordsStage: (grade, lesson, stage)=> `words/${grade}/${lesson}/${stage}`,
  progressStage: (studentKey, grade, lesson, stage)=> `progress/${studentKey}/${grade}/${lesson}/${stage}`,
  progressWord: (studentKey, grade, lesson, stage, wordId)=> `progress/${studentKey}/${grade}/${lesson}/${stage}/${wordId}`,
  lessonStageDone: (studentKey, grade, lesson, stage)=> `lessonProgress/${studentKey}/${grade}/${lesson}/${stage}`,
  wordsGrade: (grade)=> `words/${grade}`,
  bestStage: (studentKey, grade, lesson, stage)=> `bestProgress/${studentKey}/${grade}/${lesson}/${stage}`,
  asa: (studentKey)=> `asa/${studentKey}`,

  itemGroups: ()=> `itemGroups`,
  itemGroupItems: (groupKey)=> `itemGroups/${groupKey}/items`,
  itemClasses: ()=> `itemClasses`,
  charaSlots: ()=> `charaSlots`,
  quizReward: (grade, lesson, stage)=> `quizRewards/${grade}/${lesson}/${stage}`,
  shopGroups: ()=> `shopGroups`,
  itemsOwnedRoot: (studentKey)=> `itemsOwned/${studentKey}`,
  itemsOwned: (studentKey, groupKey)=> `itemsOwned/${studentKey}/${groupKey}`,
  charaItems: (studentKey)=> `charaItems/${studentKey}`,
};

/* âœ… åå‰â†’åŒä¸€é€²è¡Œï¼ˆåŒã˜åå‰ãªã‚‰åŒã˜DBãƒ‘ã‚¹ï¼‰ */
function safeKey(s){
  return encodeURIComponent(String(s).trim())
    .replaceAll(".", "%2E")
    .replaceAll("#", "%23")
    .replaceAll("$", "%24")
    .replaceAll("[", "%5B")
    .replaceAll("]", "%5D")
    .replaceAll("/", "%2F");
}
function studentKeyFromName(name){
  return "name_" + safeKey(name);
}
function groupKeyFromName(name){
  return `group_${safeKey(name)}`;
}

/* =========================
   â˜… è¨­å®šï¼ˆè§¦ã‚‹ãªã‚‰ã“ã“ï¼‰
========================= */
const QUIZ_RULES = {
  shuffleQuestions: true,
  shuffleChoices:  true,
  repeatPerWord:   1,
  maxQuestions:    "all",
  uniqueFetchTriesPerPick: 12,
 askAllWordsAlways: true,//ä»Šã¯å…¨éƒ¨å‡ºé¡Œï¼ˆå‡ºé¡Œå½¢å¼ã‚’å¤‰ãˆã‚‹ãªã‚‰ã“ã“ï¼‰
};

const QUIZ_SESSION_RULES = {
  fastMs: 2000,
  masteredFastCount: 2,
  masteredCorrectCount: 3,
  unachievedMaxShows: 5,
  endTotalWrongs: 8,
};

const DEBUG_STAGE_RATES = false;
const DEFAULT_MAX_GRADE = 8;
const GRADE_SETTINGS_PATH = "settings/gradeButtons";
  
/* âœ… ã‚¢ãƒ‹ãƒ¡ã¯â€œèƒŒæ™¯â€ã¨ã—ã¦ï¼šFPSã‚’è½ã¨ã—ã¦ã‚¯ã‚¤ã‚ºã«å¹²æ¸‰ã—ãªã„ */
const BG_ANIM_FPS_LESSON = 24;
const BG_ANIM_FPS_QUIZ   = 24;
const FLASH_VIEWS_FOR_ASA = 20;

/* ========= localStorage ========= */
const NAME_KEY  = "yuko_wordlog_name";
const GRADE_KEY = "yuko_wordlog_grade";
const CHARA_KEY = "yuko_wordlog_chara";
const DEFAULT_CHARA_LIST = ["c1", "c2", "c3"];
const INITIAL_ITEM_GROUP_NAME = "åˆæœŸã‚¢ã‚¤ãƒ†ãƒ ";
const INITIAL_ITEM_NAMES = {
  hat: "hat1",
  neck: "neck1",
  hands: "hands1",
  cloth: "cloth1",
  right: "right1",
  left: "left1",
  pants: "pants1",
  shoes: "shoes1"
};
const DEFAULT_ITEM_LAYER_Z = 35;
const DEFAULT_ITEM_LAYER_2Z = 60;
const BASE_LAYER_Z = 40;

/* ========= æ³¢ã‚²ãƒ¼ã‚¸è‰²ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰ ========= */
const GAUGE_COLOR_KEY = "yuko_wordlog_gauge_colors_v1";
const GAUGE_COLORS = [
  { name:"white",  fill:"#ffffff" },
  { name:"red",    fill:"#FF51A2" },
  { name:"yellow", fill:"#F2FF15" },
  { name:"purple", fill:"rgba(140,90,255,0.50)" },
  { name:"black",  fill:"#4E4C47" },
];
const GAUGE_ALPHA = 0.28;

let charaSlotList = [];
let charaSlotMap = new Map();
let initialItemMap = {};
let itemClassList = [];
let itemClassMap = new Map();

function normLesson(v){ return String(v ?? "").trim(); }
function normName(v){ return String(v ?? "").trim(); }
function _gaugeKey(name, grade, lesson){ return `${normName(name)}|${String(grade)}|${normLesson(lesson)}`; }

function loadGaugeColorMap(){
  try{
    const raw = localStorage.getItem(GAUGE_COLOR_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    return (obj && typeof obj === "object") ? obj : {};
  }catch(e){ return {}; }
}
function saveGaugeColorMap(map){
  try{ localStorage.setItem(GAUGE_COLOR_KEY, JSON.stringify(map||{})); }catch(e){}
}
let _gaugeColorMap = loadGaugeColorMap();

function getGaugeFill(name, grade, lesson){
  const k = _gaugeKey(name, grade, lesson);
  const idx = _gaugeColorMap[k];
  if (Number.isInteger(idx) && idx >= 0 && idx < GAUGE_COLORS.length) return GAUGE_COLORS[idx].fill;
  return null;
}
function ensureGaugeColorIfNeeded(name, grade, lesson, rate01){
  if (!name || !lesson) return;
  if (!(rate01 >= 0.01)) return;
  const k = _gaugeKey(name, grade, lesson);
  if (_gaugeColorMap[k] != null) return;
  const idx = Math.floor(Math.random() * GAUGE_COLORS.length);
  _gaugeColorMap[k] = idx;
  saveGaugeColorMap(_gaugeColorMap);
}

function getCharaImage(charaKey){
  return charaSlotMap.get(charaKey)?.image || `${charaKey}.png`;
}

function normalizeCharaSlotList(raw){
  if (!raw || typeof raw !== "object") return [];
  const list = [];
  for (const [key, value] of Object.entries(raw)){
    if (!key) continue;
    const image = String(value?.image || "").trim();
    list.push({ key, image });
  }
  list.sort((a,b)=> String(a.key).localeCompare(String(b.key), "ja"));
  return list;
}

async function loadCharaSlots({ render = true } = {}){
  try{
    const raw = await dbGet(P.charaSlots());
    const list = normalizeCharaSlotList(raw);
    if (list.length){
      charaSlotList = list;
      charaSlotMap = new Map(list.map(slot=> [slot.key, slot]));
    }
  }catch(e){
    charaSlotList = DEFAULT_CHARA_LIST.map((key)=> ({ key, image: `${key}.png` }));
    charaSlotMap = new Map(charaSlotList.map(slot=> [slot.key, slot]));
  }
  if (render) renderCharaSelectButtons();
}

function normalizeItemClassList(raw){
  if (!raw || typeof raw !== "object") return [];
  const list = [];
  for (const [key, value] of Object.entries(raw)){
    const name = String(value?.name || key).trim();
    if (!name) continue;
    const imageCount = Number(value?.imageCount || 1);
    const layer1 = Number(value?.layer1 ?? value?.image1Layer ?? DEFAULT_ITEM_LAYER_Z);
    const layer2 = Number(value?.layer2 ?? value?.image2Layer ?? DEFAULT_ITEM_LAYER_2Z);
    const thumbX = Number(value?.thumbX ?? value?.thumbOffsetX ?? 0);
    const thumbY = Number(value?.thumbY ?? value?.thumbOffsetY ?? 0);
    const gameClassOrder = Number(value?.gameClassOrder ?? value?.displayOrder ?? NaN);
    const exclusiveWith = Array.isArray(value?.exclusiveWith)
      ? value.exclusiveWith.map((v)=> String(v||"").trim()).filter(Boolean)
      : [];
    const gameClass = String(value?.gameClass || value?.displayClass || "").trim();
    const hideInGame = value?.hideInGame === true;
    list.push({
      key,
      name,
      imageCount,
      layer1,
      layer2,
      thumbX,
      thumbY,
      exclusiveWith,
      gameClass,
      gameClassOrder,
      hideInGame
    });
  }
  list.sort((a,b)=> a.name.localeCompare(b.name, "ja"));
  return list;
}

function refreshItemClassMap(list){
  itemClassList = list || [];
  itemClassMap = new Map(itemClassList.map((c)=> [c.name, c]));
}

function getItemClassConfig(itemClass){
  const key = String(itemClass || "").trim();
  return key ? itemClassMap.get(key) || null : null;
}

function getItemClassGameClass(itemClass){
  const cfg = getItemClassConfig(itemClass);
  const name = String(cfg?.gameClass || "").trim();
  return name || String(itemClass || "").trim() || "unknown";
}

function getItemClassThumbOffset(itemClass){
  const cfg = getItemClassConfig(itemClass);
  const x = Number(cfg?.thumbX ?? 0);
  const y = Number(cfg?.thumbY ?? 0);
  return {
    x: Number.isFinite(x) ? x : 0,
    y: Number.isFinite(y) ? y : 0
  };
}


function isItemClassHidden(itemClass){
  const cfg = getItemClassConfig(itemClass);
  return !!cfg?.hideInGame;
}

function getItemClassLayers(itemClass){
  const cfg = getItemClassConfig(itemClass);
  return {
    layer1: Number.isFinite(cfg?.layer1) ? cfg.layer1 : DEFAULT_ITEM_LAYER_Z,
    layer2: Number.isFinite(cfg?.layer2) ? cfg.layer2 : DEFAULT_ITEM_LAYER_2Z,
    imageCount: Number(cfg?.imageCount || 1)
  };
}

function itemClassesConflict(a, b){
  const ca = String(a || "").trim();
  const cb = String(b || "").trim();
  if (!ca || !cb) return false;
  if (ca === cb) return true;
  const cfgA = getItemClassConfig(ca);
  const cfgB = getItemClassConfig(cb);
  const exA = new Set((cfgA?.exclusiveWith || []).map((v)=> String(v||"").trim()).filter(Boolean));
  const exB = new Set((cfgB?.exclusiveWith || []).map((v)=> String(v||"").trim()).filter(Boolean));
  return exA.has(cb) || exB.has(ca);
}

function getInventoryClassOrder(itemsByClass){
  const configured = [];
  const orderMap = new Map();
  for (const cls of itemClassList){
    const name = getItemClassGameClass(cls.name);
    if (!configured.includes(name)) configured.push(name);
    if (!orderMap.has(name) && Number.isFinite(cls.gameClassOrder)){
      orderMap.set(name, cls.gameClassOrder);
    }
  }
  const classNames = [...itemsByClass.keys()];
  classNames.sort((a,b)=>{
    const orderA = orderMap.has(a) ? orderMap.get(a) : Number.POSITIVE_INFINITY;
    const orderB = orderMap.has(b) ? orderMap.get(b) : Number.POSITIVE_INFINITY;
    if (orderA !== orderB) return orderA - orderB;
    const idxA = configured.indexOf(a);
    const idxB = configured.indexOf(b);
    if (idxA !== -1 || idxB !== -1){
      if (idxA === -1) return 1;
      if (idxB === -1) return -1;
      return idxA - idxB;
    }
    return String(a).localeCompare(String(b), "ja");
  });
  return classNames;
}

async function loadItemClasses(){
  try{
    const raw = await dbGet(P.itemClasses());
    const list = normalizeItemClassList(raw);
    refreshItemClassMap(list);
  }catch(e){
    refreshItemClassMap([]);
  }
}

const INITIAL_ITEM_CLASS_BY_NAME = Object.fromEntries(
  Object.entries(INITIAL_ITEM_NAMES).map(([key, name])=> {
    const cls = key === "shoes" ? "shoes" : key;
    return [name, cls];
  })
);



function getInitialPreviewItems(){
  return Object.values(initialItemMap || {}).filter(item=> item?.image);
}

function getCharaSelectPreviewItems(){
  return getEffectiveCharaItems({ forceNeckBase: true, forceHandsBase: true });
}

const preloadedImageCache = new Set();

function collectCharaImageSources(){
  const sources = new Set();
  for (const slot of charaSlotList){
    if (!slot?.key) continue;
    sources.add(slot.image || getCharaImage(slot.key));
  }
  for (const item of Object.values(initialItemMap || {})){
    if (item?.image) sources.add(item.image);
    if (item?.image2) sources.add(item.image2);
    if (item?.listImage) sources.add(item.listImage);
  }
  for (const item of getPlacedCharaItems()){
    if (item?.image) sources.add(item.image);
    if (item?.image2) sources.add(item.image2);
    if (item?.listImage) sources.add(item.listImage);
  }
  return [...sources].filter(Boolean);
}

function preloadImages(sources){
  const tasks = [];
  for (const src of sources){
    if (preloadedImageCache.has(src)) continue;
    preloadedImageCache.add(src);
    tasks.push(new Promise((resolve)=>{
      const img = new Image();
      let done = false;
      const finish = ()=>{ if (done) return; done = true; resolve(); };
      img.loading = "eager";
      img.decoding = "async";
      img.onload = finish;
      img.onerror = finish;
      img.src = src;
      if (img.decode){
        img.decode().then(finish).catch(finish);
      }
    }));
  }
  return Promise.all(tasks);
}

function preloadCharaImages(){
  return preloadImages(collectCharaImageSources());
}

const LESSON_ASSET_SOURCES = ["kame.png", "kame2.png"];
function preloadLessonAssets(){
  return preloadImages(LESSON_ASSET_SOURCES);
}


function updateCharaSelectPreview(){
  if (!charaSelect || !charaButtons?.length) return;
  for (const btn of charaButtons){
    const key = btn.dataset.chara;
    if (!key) continue;
    const stack = btn.querySelector(".chara-stack");
    if (!stack) continue;
    const baseImage = charaSlotMap.get(key)?.image || getCharaImage(key);
    renderCharaStack(stack, baseImage, getCharaSelectPreviewItems());
  }
}


function getInitialItemKeySet(){
  const keys = new Set();
  for (const item of Object.values(initialItemMap || {})){
    if (!item?.groupKey || !item?.itemId) continue;
    keys.add(`${item.groupKey}::${item.itemId}`);
  }
  return keys;
}


function buildInitialItemMap(groupKey, group){
  const items = group?.items || {};
  const next = {};
  const groupName = String(group?.name || INITIAL_ITEM_GROUP_NAME).trim() || INITIAL_ITEM_GROUP_NAME;
  for (const [itemId, item] of Object.entries(items)){
    const name = String(item?.name || itemId || "").trim();
    const className = INITIAL_ITEM_CLASS_BY_NAME[name];
    if (!className) continue;
    next[className] = {
      itemId,
      groupKey,
      groupName,
      name,
      image: item?.image || "",
      image2: item?.image2 || "",
      class: normalizeItemClass(item?.class || className),
      listImage: item?.listImage || ""
    };
  }
  initialItemMap = next;
}

async function loadInitialItems({ render = true } = {}){
  try{
    const groups = await dbGet(P.itemGroups());
    if (!groups || typeof groups !== "object"){
      initialItemMap = {};
      if (render){
        renderCharaSelectButtons();
        renderCharaItems();
      }
      return;
    }
    const fallbackKey = groupKeyFromName(INITIAL_ITEM_GROUP_NAME);
    if (groups[fallbackKey]){
      buildInitialItemMap(fallbackKey, groups[fallbackKey]);
      if (render){
        renderCharaSelectButtons();
        renderCharaItems();
      }
      return;
    }
    for (const [key, group] of Object.entries(groups)){
      const name = String(group?.name || "").trim();
      if (name === INITIAL_ITEM_GROUP_NAME){
        buildInitialItemMap(key, group);
      if (render){
        renderCharaSelectButtons();
        renderCharaItems();
      }
        return;
      }
    }
    initialItemMap = {};
  }catch(e){
    initialItemMap = {};
  }
  if (render){
    renderCharaSelectButtons();
    renderCharaItems();
  }
}

async function ensureInitialItemsOwned(){
  if (!STUDENT.studentKey) return;
  if (!Object.keys(initialItemMap || {}).length){
    await loadInitialItems({ render:false });
  }
  const items = Object.values(initialItemMap || {}).filter(item=> item?.groupKey && item?.itemId);
  if (!items.length) return;

  const grouped = new Map();
  for (const item of items){
    if (!grouped.has(item.groupKey)) grouped.set(item.groupKey, []);
    grouped.get(item.groupKey).push(item);
  }

  const now = nowTs();
  for (const [groupKey, groupItems] of grouped.entries()){
    let owned = null;
    try{
      owned = await dbGet(P.itemsOwned(STUDENT.studentKey, groupKey));
    }catch(e){
      owned = null;
    }
    const ownedSet = owned && typeof owned === "object" ? new Set(Object.keys(owned)) : new Set();
    const writes = [];
    for (const item of groupItems){
      if (ownedSet.has(item.itemId)) continue;
      const payload = {
        name: item.name || item.itemId,
        image: item.image || "",
        image2: item.image2 || "",
        class: item.class || "",
        listImage: item.listImage || "",
        groupKey: item.groupKey,
        groupName: item.groupName || "",
        acquiredAt: now
      };
      writes.push(dbSet(`${P.itemsOwned(STUDENT.studentKey, groupKey)}/${item.itemId}`, payload));
    }
    if (writes.length) await Promise.all(writes);
  }
}


/* ========= DOM ========= */
const studentTop = document.getElementById("studentTop");
const stuName = document.getElementById("stuName");
const btnStart = document.getElementById("btnStart");
const stuStatus = document.getElementById("stuStatus");
const charaSelect = document.getElementById("charaSelect");
let charaButtons = [];
const lessonListBox = document.getElementById("lessonListBox");
const lessonList = document.getElementById("lessonList");
const lessonSvg = document.getElementById("lessonSvg");
const lessonChara = document.getElementById("lessonChara");
const lessonCharaStack = document.getElementById("lessonCharaStack");
const asaPop = document.getElementById("asaPop");
const asaValue = document.getElementById("asaValue");
const asaCircle = document.getElementById("asaCircle");
const asaCoinCanvas = document.getElementById("asaCoinCanvas");
const stagePop = document.getElementById("stagePop");
const stagePopTitle = document.getElementById("stagePopTitle");
const btnStagePre1 = document.getElementById("btnStagePre1");
const btnStagePre2 = document.getElementById("btnStagePre2");
const btnStageReview = document.getElementById("btnStageReview");

const quizBox = document.getElementById("quizBox");
const lessonInfo = document.getElementById("lessonInfo");
const stageBadge = document.getElementById("stageBadge");
const hint = document.getElementById("hint");
const quizWord = document.getElementById("quizWord");
const optGrid = document.getElementById("optGrid");
const quizResult = document.getElementById("quizResult");
const btnNext = document.getElementById("btnNext");
const btnLessonComplete = document.getElementById("btnLessonComplete");
const btnBackLessons = document.getElementById("btnBackLessons");
const quizExample = document.getElementById("quizExample");

const quizStage = document.getElementById("quizStage");
const quizProgressSvg = document.getElementById("quizProgressSvg");
const reviewBallSvg = document.getElementById("reviewBallSvg");
const dropletLayer = document.getElementById("dropletLayer");

const gradeFab = document.getElementById("gradeFab");
const backFab = document.getElementById("backFab");

const qTimer = document.getElementById("qTimer");
const qTimerFg = document.getElementById("qTimerFg");

/* âœ… ã‚»ãƒƒã‚·ãƒ§ãƒ³çµæœDOM */
const sessionBack = document.getElementById("sessionBack");
const sessionPct  = document.getElementById("sessionPct");
const sessionReward = document.getElementById("sessionReward");
const wrongList   = document.getElementById("wrongList");
const btnSessionClose = document.getElementById("btnSessionClose");
const sessionTitle = document.getElementById("sessionTitle");
const sessionTitleText = document.getElementById("sessionTitleText");
const sessionAsaGain = document.getElementById("sessionAsaGain");
const sessionAsaValue = document.getElementById("sessionAsaValue");
const sessionAsaCoin = document.getElementById("sessionAsaCoin");

/* âœ… æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ DOM */
const inventoryBack = document.getElementById("inventoryBack");
const inventoryMsg = document.getElementById("inventoryMsg");
const inventoryBody = document.getElementById("inventoryBody");
const inventoryCharaStage = document.getElementById("inventoryCharaStage");
const inventoryCharaStack = document.getElementById("inventoryCharaStack");
const shopBack = document.getElementById("shopBack");
const shopGrid = document.getElementById("shopGrid");
const shopEmpty = document.getElementById("shopEmpty");
const shopClose = document.getElementById("shopClose");
const shopPurchaseBack = document.getElementById("shopPurchaseBack");
const shopPurchaseImg = document.getElementById("shopPurchaseImg");
const shopPurchasePrice = document.getElementById("shopPurchasePrice");
const shopPurchaseActions = document.getElementById("shopPurchaseActions");
const shopPurchaseBtn = document.getElementById("shopPurchaseBtn");
const shopCancelBtn = document.getElementById("shopCancelBtn");
const shopPurchaseStatus = document.getElementById("shopPurchaseStatus");
const shopTimer = document.getElementById("shopTimer");
/* âœ… lowRateãƒãƒƒãƒ—DOM */
const lowRateBack = document.getElementById("lowRateBack");
const lowRateTitle = document.getElementById("lowRateTitle");
const lowRateList = document.getElementById("lowRateList");
const btnLowRateStart = document.getElementById("btnLowRateStart");
const btnLowRateMem = document.getElementById("btnLowRateMem");
/* âœ… ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰DOMï¼ˆãŠã¼ãˆã‚‹ğŸ‘€ï¼‰ */
const flashBack   = document.getElementById("flashBack");
const flashCard   = document.getElementById("flashCard");
const flashList   = document.getElementById("flashList");
const flashPager  = document.getElementById("flashPager");
const flashModeWrap = document.getElementById("flashModeWrap");
const flashModeUnified = document.getElementById("flashModeUnified");
const topLoading = document.getElementById("topLoading");

/* ========= ASA ========= */
let ASA_STATE = {
  total: 0,
  flashRemainder: 0,
  loaded: false
};

function normalizeAsa(obj){
  const base = (obj && typeof obj === "object") ? obj : {};
  const total = Number(base.total);
  const remainder = Number(base.flashRemainder ?? base.flashViewed ?? 0);
  return {
    total: Number.isFinite(total) && total > 0 ? Math.trunc(total) : 0,
    flashRemainder: Number.isFinite(remainder) && remainder > 0 ? Math.trunc(remainder) : 0
  };
}
function applyAsaState(obj){
  const { total, flashRemainder } = normalizeAsa(obj);
  ASA_STATE.total = total;
  ASA_STATE.flashRemainder = Math.max(0, flashRemainder % FLASH_VIEWS_FOR_ASA);
  ASA_STATE.loaded = true;
  renderAsaPop();
}

function drawAsaCoinOn(canvas, options = {}){
  if (!canvas) return;
  const expand = Number(options.expand || 0);
  const sizePx = getComputedStyle(canvas).width;
  const size = Math.max(12, Math.round(parseFloat(sizePx) || 0));
  const scale = window.devicePixelRatio || 1;
  canvas.width = size * scale;
  canvas.height = size * scale;
  canvas.style.width = `${size + expand}px`;
  canvas.style.height = `${size + expand}px`;
  const ctx = canvas.getContext("2d");
  if (!ctx) return;
  ctx.setTransform(scale, 0, 0, scale, 0, 0);
  ctx.clearRect(0, 0, size, size);
  const cx = size * 0.45;
  const cy = size * 0.5;
  const r = size * 0.28;
  const depth = size * 0.12;

  ctx.beginPath();
  ctx.arc(cx + depth, cy, r, -Math.PI / 2, Math.PI / 2);
  ctx.lineTo(cx + depth, cy + r);
  ctx.arc(cx, cy, r, Math.PI / 2, -Math.PI / 2, true);
  ctx.closePath();
  ctx.fillStyle = "#9a5f2e";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = "#c1844d";
  ctx.fill();

  ctx.lineWidth = Math.max(1, size * 0.015);
  ctx.strokeStyle = "#5a3216";
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(cx, cy, r - size * 0.045, 0, Math.PI * 2);
  ctx.lineWidth = Math.max(1, size * 0.01);
  ctx.strokeStyle = "rgba(0,0,0,0.22)";
  ctx.stroke();


}
function drawAsaCoin(){
  drawAsaCoinOn(asaCoinCanvas, { expand: 20 });
}


function syncAsaCircleSize(){
  if (!asaPop) return;
  const h = asaPop.offsetHeight;
  if (!(h > 0)) return;
  const size = Math.max(8, h - 8);
  const sizePx = `${size}px`;
  const sizePxGold = `${size + 4}px`;
  if (asaCircle){
    asaCircle.style.setProperty("--asaCircleSize", sizePx);
    asaCircle.style.width = asaCircle.style.height = sizePx;
  }
  if (asaCoinCanvas){
    asaCoinCanvas.style.setProperty("--asaCircleSize", sizePxGold);
    asaCoinCanvas.style.width = asaCoinCanvas.style.height = sizePxGold;
    drawAsaCoin();
  }
}

function renderAsaPop(){
  if (!asaPop || !asaValue) return;
  const show = (lessonListBox && lessonListBox.style.display !== "none");
  asaPop.style.display = show ? "flex" : "none";
  if (asaCircle) asaCircle.style.display = show ? "block" : "none";
  if (asaCoinCanvas) asaCoinCanvas.style.display = show ? "block" : "none";
  asaValue.textContent = String(ASA_STATE.total);
  if (show) syncAsaCircleSize();
}
async function loadAsa(){
  if (!STUDENT.studentKey) return;
  try{
    const raw = await dbGet(P.asa(STUDENT.studentKey));
    applyAsaState(raw);
  }catch(_){
    applyAsaState(null);
  }
}
async function updateAsaViaTransaction(modifier){
  if (!STUDENT.studentKey) return;
  const path = ref(db, P.asa(STUDENT.studentKey));
  const res = await runTransaction(path, (cur)=>{
    const base = normalizeAsa(cur);
    const next = modifier({
      total: Math.max(0, base.total),
      flashRemainder: Math.max(0, base.flashRemainder || 0)
    }) || base;
    next.updatedAt = nowTs();
    return next;
  });
  applyAsaState(res?.snapshot?.val());
}
async function addAsaPoints(n){
  const delta = Number(n);
  if (!Number.isFinite(delta) || delta <= 0) return;
  try{
    await updateAsaViaTransaction((state)=>{
      state.total += delta;
      return state;
    });
  }catch(_){}
}
async function recordFlashViews(n){
  const delta = Number(n);
  if (!Number.isFinite(delta) || delta <= 0) return;
  try{
    await updateAsaViaTransaction((state)=>{
      state.flashRemainder += delta;
      if (state.flashRemainder >= FLASH_VIEWS_FOR_ASA){
        const bonus = Math.trunc(state.flashRemainder / FLASH_VIEWS_FOR_ASA);
        state.flashRemainder = state.flashRemainder % FLASH_VIEWS_FOR_ASA;
        state.total += bonus;
      }
      return state;
    });
  }catch(_){}
}
function calcAsaFromPct(pct){
  if (!(pct >= 0)) return 0;
  if (pct >= 100) return 3;
  if (pct >= 90) return 2;
  if (pct >= 80) return 1;
  return 0;
}
async function awardAsaForSession(pct){
  if (!SESSION || SESSION.asaAwarded) return;
  SESSION.asaAwarded = true;
  const pts = calcAsaFromPct(pct);
  if (!pts) return;
  await addAsaPoints(pts);
}

const SHOP_REFRESH_MS = 120000;
const SHOP_ITEM_COUNT = 9;
let SHOP_STATE = {
  pool: [],
  current: [],
  lastRefresh: 0,
  slot: null,
  timer: null,
  ownedByGroup: new Map(),
  loading: false
};
let currentShopItem = null;

function hashStringToSeed(str){
  let hash = 2166136261;
  for (let i=0; i<str.length; i++){
    hash ^= str.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}

function seededShuffle(list, rng){
  for (let i=list.length - 1; i>0; i--){
    const j = Math.floor(rng() * (i + 1));
    [list[i], list[j]] = [list[j], list[i]];
  }
  return list;
}

function getShopSlot(now = Date.now()){
  return Math.floor(now / SHOP_REFRESH_MS);
}

function getShopNextRefreshAt(now = Date.now()){
  return (getShopSlot(now) + 1) * SHOP_REFRESH_MS;
}

function formatShopCountdown(ms){
  const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${String(seconds).padStart(2, "0")}`;
}

function updateShopTimerDisplay(now = Date.now()){
  if (!shopTimer) return;
  const remain = getShopNextRefreshAt(now) - now;
  shopTimer.textContent = `ãŠåº—ã®å•†å“ãŒå¤‰ã‚ã‚‹ã¾ã§ ${formatShopCountdown(remain)}`;
}


function normalizeShopPrice(value){
  const num = Number(value);
  if (!Number.isFinite(num) || num < 0) return 0;
  return Math.trunc(num);
}

function getShopThumb(item){
  return item?.listImage || item?.image || "";
}

function setShopEmptyMessage(message){
  if (!shopEmpty) return;
  shopEmpty.textContent = message;
  shopEmpty.style.display = message ? "block" : "none";
}

async function loadShopPool(){
  if (SHOP_STATE.loading) return;
  SHOP_STATE.loading = true;
  try{
    const [groupRoot, shopGroups, ownedRoot] = await Promise.all([
      dbGet(P.itemGroups()).catch(()=> null),
      dbGet(P.shopGroups()).catch(()=> null),
      dbGet(P.itemsOwnedRoot(STUDENT.studentKey)).catch(()=> null)
    ]);

    const ownedByGroup = new Map();
    if (ownedRoot && typeof ownedRoot === "object"){
      for (const [groupKey, items] of Object.entries(ownedRoot)){
        if (!items || typeof items !== "object") continue;
        ownedByGroup.set(groupKey, new Set(Object.keys(items)));
      }
    }

    const pool = [];
    if (groupRoot && shopGroups && typeof shopGroups === "object"){
      for (const [groupKey, shopEntry] of Object.entries(shopGroups)){
        const group = groupRoot[groupKey];
        if (!group || typeof group !== "object") continue;
        const items = group?.items || {};
        const shopName = typeof shopEntry === "string" ? shopEntry : shopEntry?.name;
        const groupName = String(group?.name || shopName || groupKey);
        for (const [itemId, item] of Object.entries(items)){
          if (!item || item.disabled) continue;
          pool.push({
            itemId,
            groupKey,
            groupName,
            name: String(item?.name || itemId),
            image: item?.image || "",
            image2: item?.image2 || "",
            class: item?.class || "",
            listImage: item?.listImage || "",
            asaPrice: normalizeShopPrice(item?.asaPrice)
          });
        }
      }
    }

    SHOP_STATE.pool = pool;
    SHOP_STATE.ownedByGroup = ownedByGroup;
  }catch(_){
    SHOP_STATE.pool = [];
  }finally{
    SHOP_STATE.loading = false;
  }
}

function renderShopItems(list){
  if (!shopGrid) return;
  shopGrid.innerHTML = "";
  if (!list.length){
    setShopEmptyMessage("ã‚·ãƒ§ãƒƒãƒ—ã«è¡¨ç¤ºã§ãã‚‹ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
    return;
  }
  setShopEmptyMessage("");
  for (const item of list){
    const button = document.createElement("button");
    button.type = "button";
    button.className = "shopItem";
    const thumb = getShopThumb(item);
    const thumbOffset = getItemClassThumbOffset(item?.class);
    const price = normalizeShopPrice(item.asaPrice);
    if (item?.listImage){
      button.dataset.thumb = "full";
    }
    button.style.setProperty("--thumb-x", `${thumbOffset.x}%`);
    button.style.setProperty("--thumb-y", `${thumbOffset.y}%`);
    button.innerHTML = `
      <div class="shopItemThumb">
        <img src="${escapeHtml(thumb)}" alt="${escapeHtml(item.name)}">
      </div>
      <div class="shopPrice">${price} ASA</div>
    `;
    button.onclick = ()=> openShopPurchase(item);
    shopGrid.appendChild(button);
  }
}

function refreshShopSelection(force = false){
  if (!SHOP_STATE.pool.length){
    renderShopItems([]);
    return;
  }
  const now = Date.now();
  const slot = getShopSlot(now);
  if (!force && SHOP_STATE.current.length && SHOP_STATE.slot === slot){
    renderShopItems(SHOP_STATE.current);
    updateShopTimerDisplay(now);
    return;
  }
  const sortedPool = SHOP_STATE.pool.slice().sort((a, b)=>{
    const keyA = `${a.groupKey}::${a.itemId}`;
    const keyB = `${b.groupKey}::${b.itemId}`;
    return keyA.localeCompare(keyB);
  });
  const seed = hashStringToSeed(`shop:${slot}`);
  const rng = mulberry32(seed);
  const shuffled = seededShuffle(sortedPool, rng);
  SHOP_STATE.current = shuffled.slice(0, SHOP_ITEM_COUNT);
  SHOP_STATE.lastRefresh = now;
  SHOP_STATE.slot = slot;
  renderShopItems(SHOP_STATE.current);
  updateShopTimerDisplay(now);
}

function startShopRotation(){
  stopShopRotation();
  updateShopTimerDisplay();
  SHOP_STATE.timer = setInterval(()=>{
    const now = Date.now();
    if (shopBack && shopBack.style.display !== "none"){
      const slot = getShopSlot(now);
      updateShopTimerDisplay(now);
      if (SHOP_STATE.slot !== slot){
        refreshShopSelection(true);
      }
    }
  }, 1000);
}

function stopShopRotation(){
  if (SHOP_STATE.timer){
    clearInterval(SHOP_STATE.timer);
    SHOP_STATE.timer = null;
  }
}

async function openShop(){
  if (!shopBack) return;
  if (!STUDENT.studentKey) return;
  shopBack.style.display = "flex";
  await loadShopPool();
  refreshShopSelection(false);
  startShopRotation();
}

function closeShop(){
  if (!shopBack) return;
  shopBack.style.display = "none";
  stopShopRotation();
  closeShopPurchase();
}

function openShopPurchase(item){
  if (!shopPurchaseBack || !shopPurchaseImg) return;
  currentShopItem = item;
  const thumb = getShopThumb(item);
  shopPurchaseImg.src = thumb || "";
  shopPurchaseImg.alt = item?.name || "è³¼å…¥ã‚¢ã‚¤ãƒ†ãƒ ";
  const price = normalizeShopPrice(item?.asaPrice);
  if (shopPurchasePrice){
    shopPurchasePrice.textContent = `${price} ASA`;
  }
  if (shopPurchaseStatus) shopPurchaseStatus.textContent = "";
  if (shopPurchaseActions) shopPurchaseActions.style.display = "flex";
  if (shopPurchaseBtn) shopPurchaseBtn.disabled = false;

  const ownedSet = SHOP_STATE.ownedByGroup.get(item.groupKey) || new Set();
  if (ownedSet.has(item.itemId)){
    if (shopPurchaseStatus) shopPurchaseStatus.textContent = "ã‚‚ã†æŒã£ã¦ã„ã¾ã™ã€‚";
    if (shopPurchaseActions) shopPurchaseActions.style.display = "none";
  }else if (shopPurchaseBtn){
    shopPurchaseBtn.disabled = ASA_STATE.total < price;
    if (shopPurchaseBtn.disabled){
      if (shopPurchaseStatus) shopPurchaseStatus.textContent = "ASAãŒè¶³ã‚Šã¾ã›ã‚“";
    }
  }

  shopPurchaseBack.style.display = "flex";
}

function closeShopPurchase(){
  if (!shopPurchaseBack) return;
  shopPurchaseBack.style.display = "none";
  currentShopItem = null;
}

async function purchaseShopItem(){
  if (!currentShopItem || !STUDENT.studentKey) return;
  const item = currentShopItem;
  const price = normalizeShopPrice(item?.asaPrice);
  let canBuy = false;
  try{
    await updateAsaViaTransaction((state)=>{
      if (state.total < price) return state;
      state.total -= price;
      canBuy = true;
      return state;
    });
  }catch(_){
    canBuy = false;
  }
  if (!canBuy){
    if (shopPurchaseStatus) shopPurchaseStatus.textContent = "ASAãŒè¶³ã‚Šã¾ã›ã‚“";
    if (shopPurchaseBtn) shopPurchaseBtn.disabled = true;
    return;
  }

  const payload = {
    name: item?.name || item?.itemId || "ã‚¢ã‚¤ãƒ†ãƒ ",
    image: item?.image || "",
    image2: item?.image2 || "",
    class: item?.class || "",
    listImage: item?.listImage || "",
    groupKey: item?.groupKey || "",
    groupName: item?.groupName || item?.groupKey || "",
    acquiredAt: nowTs()
  };
  try{
    await dbSet(`${P.itemsOwned(STUDENT.studentKey, item.groupKey)}/${item.itemId}`, payload);
    markInventoryNeedsLoad();
    await loadInventoryIfNeeded({ force: true });
  }catch(_){
    if (shopPurchaseStatus) shopPurchaseStatus.textContent = "è³¼å…¥å¤±æ•—ï¼ˆä¿å­˜ã§ãã¾ã›ã‚“ï¼‰";
    return;
  }

  const ownedSet = SHOP_STATE.ownedByGroup.get(item.groupKey) || new Set();
  ownedSet.add(item.itemId);
  SHOP_STATE.ownedByGroup.set(item.groupKey, ownedSet);
  SHOP_STATE.pool = SHOP_STATE.pool.filter((entry)=> !(entry.groupKey === item.groupKey && entry.itemId === item.itemId));
  refreshShopSelection(true);

  if (shopPurchaseActions) shopPurchaseActions.style.display = "none";
  if (shopPurchaseStatus) shopPurchaseStatus.textContent = "è³¼å…¥ã—ã¾ã—ãŸ";
}


async function getRewardCandidates(){
  if (!SESSION) return [];
  const grade = SELECTED_GRADE;
  const lesson = normLesson(SESSION.lesson);
  const stage = String(SESSION.stage || "");
  if (!STUDENT.studentKey || !grade || !lesson || !stage) return [];
  const reward = await dbGet(P.quizReward(grade, lesson, stage));
  const groupKeys = Array.isArray(reward?.groupKeys)
    ? reward.groupKeys
    : (reward?.groupKey ? [reward.groupKey] : []);
  const groupNames = Array.isArray(reward?.groupNames)
    ? reward.groupNames
    : (reward?.groupName ? [reward.groupName] : []);
  if (!groupKeys.length) return [];
  const groupNameMap = new Map();
  groupKeys.forEach((key, idx)=>{
    const name = groupNames[idx] || reward?.groupName || key;
    groupNameMap.set(key, name);
  });
  const candidates = [];
  for (const key of groupKeys){
    if (!key) continue;
    const items = await dbGet(P.itemGroupItems(key));
    if (!items || typeof items !== "object") continue;
    const owned = await dbGet(P.itemsOwned(STUDENT.studentKey, key));
    const ownedSet = owned && typeof owned === "object" ? new Set(Object.keys(owned)) : new Set();
    for (const [itemId, item] of Object.entries(items)){
      if (ownedSet.has(itemId)) continue;
      candidates.push({ itemId, item, groupKey: key, groupName: groupNameMap.get(key) || key });
    }
  }
  return candidates;
}

async function prepareSessionReward(){
  if (!SESSION || SESSION.rewardPrepared) return;
  SESSION.rewardPrepared = true;
  const candidates = await getRewardCandidates();
  if (!candidates.length) return;
  const pick = candidates[Math.floor(Math.random() * candidates.length)];
  const { itemId, item, groupKey, groupName } = pick;
  const payload = {
    name: item?.name || itemId,
    image: item?.image || "",
    image2: item?.image2 || "",
    class: item?.class || "",
    listImage: item?.listImage || "",
    groupKey,
    groupName,
    acquiredAt: nowTs(),
  };
  SESSION.preparedReward = { itemId, groupKey, payload };
  const sources = [payload.image, payload.image2, payload.listImage].filter(Boolean);
  if (sources.length) await preloadImages(sources);
}

async function awardItemForSession(pct){
  if (!SESSION || SESSION.itemAwarded) return null;
  SESSION.itemAwarded = true;
  if (!(pct >= 100)) return null;
  const prepared = SESSION.preparedReward;
  if (prepared && prepared.payload){
    await dbSet(`${P.itemsOwned(STUDENT.studentKey, prepared.groupKey)}/${prepared.itemId}`, prepared.payload);
    markInventoryNeedsLoad();
    await loadInventoryIfNeeded({ force: true });
    return prepared.payload;
  }
  const candidates = await getRewardCandidates();


  if (!candidates.length) return null;
  const pick = candidates[Math.floor(Math.random() * candidates.length)];
  const { itemId, item, groupKey, groupName } = pick;
  const payload = {
    name: item?.name || itemId,
    image: item?.image || "",
    image2: item?.image2 || "",
    class: item?.class || "",
    listImage: item?.listImage || "",
    groupKey,
    groupName,
    acquiredAt: nowTs(),
  };
  await dbSet(`${P.itemsOwned(STUDENT.studentKey, groupKey)}/${itemId}`, payload);
  markInventoryNeedsLoad();
  await loadInventoryIfNeeded({ force: true });
  return payload;
}

const CHARA_BASE_LAYER_Z = BASE_LAYER_Z;

let charaItemPlacements = {};
let _charaItemCacheKey = "";
let _charaItemRenderTick = null;
let inventoryNeedsLoad = true;
let inventoryLoadedStudentKey = "";

function markInventoryNeedsLoad(){
  inventoryNeedsLoad = true;
}
async function loadInventoryIfNeeded({ force = false } = {}){
  const studentKey = STUDENT.studentKey || "";
  if (!force && !inventoryNeedsLoad && inventoryLoadedStudentKey === studentKey) return;
  const loaded = await loadInventory().catch(()=> false);
  if (loaded){
    inventoryNeedsLoad = false;
    inventoryLoadedStudentKey = studentKey;
  }
}

function getCharaItemCacheKey(){
  if (!STUDENT.studentKey) return "";
  return `${STUDENT.studentKey}`;
}

function getCharaItemPath(){
  if (!STUDENT.studentKey) return null;
  return P.charaItems(STUDENT.studentKey);
}
function renderInventoryChara(){
  if (!inventoryCharaStack) return;
  const saved = getSavedChara();
  if (!saved){
    inventoryCharaStack.innerHTML = "";
    return;
  }
  renderCharaStack(
    inventoryCharaStack,
    getCharaImage(saved),
    getEffectiveCharaItems({ forceNeckBase: true, forceHandsBase: true })
  );
}
function normalizeCharaItemPlacement(raw){
  const itemClass = normalizeItemClass(raw?.class);
  return {
    itemId: raw?.itemId || "",
    groupKey: raw?.groupKey || "",
    name: raw?.name || "",
    image: raw?.image || "",
    image2: raw?.image2 || "",
    class: itemClass,
    listImage: raw?.listImage || ""
  };
}
function scheduleCharaItemsRender(){
  if (_charaItemRenderTick) cancelAnimationFrame(_charaItemRenderTick);
  _charaItemRenderTick = requestAnimationFrame(()=>{
    _charaItemRenderTick = null;
    renderCharaItems();
  });
}
function renderCharaItemsImmediate(){
  if (_charaItemRenderTick) cancelAnimationFrame(_charaItemRenderTick);
  _charaItemRenderTick = null;
  renderCharaItems();
}

function normalizeItemClass(value){
  const raw = String(value || "").trim();
  return raw || "unknown";
}

function renderCharaStacksNow(){
  const saved = getSavedChara();
  const baseImage = saved ? getCharaImage(saved) : "";
  if (inventoryCharaStack){
    const items = getEffectiveCharaItems({ forceNeckBase: true, forceHandsBase: true });
    renderCharaStack(inventoryCharaStack, baseImage, items);
  }
  if (lessonCharaStack){
    const items = getEffectiveCharaItems();
    renderCharaStack(lessonCharaStack, baseImage, items);
  }
}

function renderCharaPreviewImmediate(){
  if (_charaItemRenderTick) cancelAnimationFrame(_charaItemRenderTick);
  _charaItemRenderTick = null;
  renderCharaStacksNow();
}

function getCharaLayerZ(itemClass, imageIndex = 1){
  if (!itemClass) return DEFAULT_ITEM_LAYER_Z;
  const layers = getItemClassLayers(itemClass);
  if (imageIndex === 2) return layers.layer2 ?? DEFAULT_ITEM_LAYER_2Z;
  return layers.layer1 ?? DEFAULT_ITEM_LAYER_Z;
}
function getPlacedCharaItems(){
  return Object.values(charaItemPlacements || {}).map(normalizeCharaItemPlacement);
}
function getInitialItemByClass(itemClass){
  const cls = normalizeItemClass(itemClass);
  if (!cls || cls === "unknown") return null;
  const item = initialItemMap?.[cls];
  if (!item?.image) return null;
  return item;
}
function isSameCharaItem(a, b){
  if (!a || !b) return false;
  if (a.groupKey && b.groupKey && a.itemId && b.itemId){
    return a.groupKey === b.groupKey && a.itemId === b.itemId;
  }
  return Boolean(a.image && b.image && a.image === b.image);
}
function getEffectiveCharaItems({ forceNeckBase = false, forceHandsBase = false } = {}){
  const placed = getPlacedCharaItems();
  const placedByClass = new Map();
  const extras = [];
  for (const item of placed){
    const cls = normalizeItemClass(item?.class);
    if (cls && cls !== "unknown" && !placedByClass.has(cls)){
      placedByClass.set(cls, item);
    } else if (cls === "unknown"){
      extras.push(item);
    }
  }
  const fallbackItems = [];
  for (const item of Object.values(initialItemMap || {})){
    const cls = normalizeItemClass(item?.class);
    if (cls && cls !== "unknown" && !placedByClass.has(cls)){
      fallbackItems.push(item);
    }
  }
  const forcedItems = [];
  if (forceNeckBase){
    const neckBase = getInitialItemByClass("neck");
    if (neckBase){
      const alreadyHas = placed.some((item)=> isSameCharaItem(item, neckBase))
        || fallbackItems.some((item)=> isSameCharaItem(item, neckBase));
      if (!alreadyHas){
        forcedItems.push(neckBase);
      }
    }
  }

  if (forceHandsBase){
    const handsBase = getInitialItemByClass("hands");
    if (handsBase){
      const alreadyHas = placed.some((item)=> isSameCharaItem(item, handsBase))
        || fallbackItems.some((item)=> isSameCharaItem(item, handsBase));
      if (!alreadyHas){
        forcedItems.push(handsBase);
      }
    }
  }

  const selected = [...placedByClass.values()];
  const filteredForced = [];
  const filteredFallback = [];
  const canAdd = (item)=>{
    const cls = normalizeItemClass(item?.class);
    if (!cls || cls === "unknown") return true;
    return !selected.some((entry)=> itemClassesConflict(cls, normalizeItemClass(entry?.class)));
  };

  for (const item of forcedItems){
    if (!canAdd(item)) continue;
    filteredForced.push(item);
    selected.push(item);
  }
  for (const item of fallbackItems){
    if (!canAdd(item)) continue;
    filteredFallback.push(item);
    selected.push(item);
  }

  return [...filteredForced, ...placedByClass.values(), ...extras, ...filteredFallback];
}
function renderCharaStack(container, baseImage, items){
  if (!container) return;
  container.innerHTML = "";
  const layers = [];
  if (Array.isArray(items)){
    for (const item of items){
      if (!item?.image) continue;
      layers.push({
        src: item.image,
        alt: item.name || "item",
        z: getCharaLayerZ(item.class, 1)
      });
     if (item?.image2){
        layers.push({
          src: item.image2,
          alt: `${item.name || "item"} (2)`,
          z: getCharaLayerZ(item.class, 2)
        });
      }
    }
  }
  if (baseImage){
    layers.push({
      src: baseImage,
      alt: "chara",
      z: CHARA_BASE_LAYER_Z
    });
  }
  layers.sort((a,b)=> a.z - b.z);
  for (const layer of layers){
    const img = document.createElement("img");
    img.className = "chara-layer";
    img.src = layer.src;
    img.alt = layer.alt;
    img.loading = "eager";
    img.decoding = "async";
    img.style.zIndex = String(layer.z);
    img.draggable = false;
    container.appendChild(img);
  }
}
function updateInventoryPlacedState(){
  if (!inventoryBody) return;
  inventoryBody.querySelectorAll(".inventoryItem").forEach((card)=>{
    const key = card.dataset.itemKey;
    card.classList.toggle("is-placed", Boolean(key && charaItemPlacements?.[key]));
  });
  reorderInventoryItems();
}
function reorderInventoryItems(){
  if (!inventoryBody) return;
  inventoryBody.querySelectorAll(".inventoryGrid").forEach((grid)=>{
    const cards = [...grid.querySelectorAll(".inventoryItem")];
    cards.sort((a, b)=>{
      const aPlaced = Boolean(charaItemPlacements?.[a.dataset.itemKey]);
      const bPlaced = Boolean(charaItemPlacements?.[b.dataset.itemKey]);
      if (aPlaced === bPlaced) return 0;
      return aPlaced ? -1 : 1;
    });
    cards.forEach((card)=> grid.appendChild(card));
  });
}

function findPlacedItemKeysByClass(itemClass){
  if (!itemClass) return [];
  const keys = [];
  for (const [key, placement] of Object.entries(charaItemPlacements || {})){
    const placedClass = normalizeItemClass(placement?.class);
    if (itemClassesConflict(itemClass, placedClass)) keys.push(key);
  }
  return keys;
}
function findPlacedItemKeyByClass(itemClass){
  return findPlacedItemKeysByClass(itemClass)[0] || null;
}
async function ensureUniqueClassPlacements(){
  const path = getCharaItemPath();
  const removals = [];
  const kept = [];
  for (const [key, placement] of Object.entries(charaItemPlacements || {})){
    const cls = normalizeItemClass(placement?.class);
    if (!cls || cls === "unknown"){
      kept.push({ key, cls });
      continue;
    }
    const conflict = kept.find((entry)=> itemClassesConflict(cls, entry.cls));
    if (conflict){
      delete charaItemPlacements[key];
      if (path) removals.push(dbSet(`${path}/${key}`, null));
    }else{
      kept.push({ key, cls });
    }
  }
  if (removals.length) await Promise.all(removals);
}

async function ensureInitialClassPlacements({ render = true } = {}){
  if (!Object.keys(initialItemMap || {}).length){
    await loadInitialItems({ render: false });
  }
  const additions = [];
  for (const item of Object.values(initialItemMap || {})){
    const cls = normalizeItemClass(item?.class);
    if (!cls || cls === "unknown") continue;
    const existingKey = findPlacedItemKeyByClass(cls);
    if (existingKey) continue;
    if (!item?.groupKey || !item?.itemId) continue;
    const itemKey = `${item.groupKey}::${item.itemId}`;
    const placement = normalizeCharaItemPlacement({
      itemId: item.itemId,
      groupKey: item.groupKey,
      name: item.name || item.itemId,
      image: item.image || "",
      image2: item.image2 || "",
      class: cls,
      listImage: item.listImage || ""
    });
    charaItemPlacements[itemKey] = placement;
    additions.push({ itemKey, placement });
  }
  if (!additions.length) return;
  if (render){
    renderCharaPreviewImmediate();
    updateInventoryPlacedState();
  }
  await Promise.all(additions.map(({ itemKey, placement })=> persistCharaItemPlacement(itemKey, placement)));
}


async function loadCharaItemPlacements(){
  const key = getCharaItemCacheKey();
  if (!key){
    charaItemPlacements = {};
    _charaItemCacheKey = "";
    renderCharaPreviewImmediate();
    updateInventoryPlacedState();
    updateCharaSelectPreview();
    return;
  }
  if (key === _charaItemCacheKey && Object.keys(charaItemPlacements).length){
    scheduleCharaItemsRender();
    updateInventoryPlacedState();
    updateCharaSelectPreview();
    return;
  }
  _charaItemCacheKey = key;
  try{
    const path = getCharaItemPath();
    const data = path ? await dbGet(path) : null;
    if (data && typeof data === "object"){
      const next = {};
      for (const [itemKey, raw] of Object.entries(data)){
        next[itemKey] = normalizeCharaItemPlacement(raw);
      }
      charaItemPlacements = next;
    } else {
      charaItemPlacements = {};
    }
  }catch(e){
    charaItemPlacements = {};
  }
  await ensureUniqueClassPlacements();
  await ensureInitialClassPlacements({ render: false });
  scheduleCharaItemsRender();
  updateInventoryPlacedState();
  updateCharaSelectPreview();
}
async function saveCharaItemPlacement(itemKey, payload){
  const path = getCharaItemPath();
  if (!path || !itemKey) return;
  const placement = normalizeCharaItemPlacement(payload);
  charaItemPlacements[itemKey] = placement;
  renderCharaPreviewImmediate();
  updateInventoryPlacedState();
  updateCharaSelectPreview();
  try{
    await dbSet(`${path}/${itemKey}`, placement);
  }catch(e){}
}
async function removeCharaItemPlacement(itemKey){
  const path = getCharaItemPath();
  if (!path || !itemKey) return;
  delete charaItemPlacements[itemKey];
  renderCharaPreviewImmediate();
  updateInventoryPlacedState();
  updateCharaSelectPreview();
  try{
    await dbSet(`${path}/${itemKey}`, null);
  }catch(e){}
}

async function persistCharaItemPlacement(itemKey, placement){
  const path = getCharaItemPath();
  if (!path || !itemKey) return;
  try{
    await dbSet(`${path}/${itemKey}`, placement);
  }catch(e){}
}
async function persistCharaItemRemoval(itemKey){
  const path = getCharaItemPath();
  if (!path || !itemKey) return;
  try{
    await dbSet(`${path}/${itemKey}`, null);
  }catch(e){}
}

async function removeAllCharaItemPlacements(){
  const path = getCharaItemPath();
  if (!path) return;
  const keys = Object.keys(charaItemPlacements || {});
  if (!keys.length) return;
  charaItemPlacements = {};
  scheduleCharaItemsRender();
  updateInventoryPlacedState();
  try{
    await dbSet(path, null);
  }catch(e){}
}
async function removeUnownedCharaItemPlacements(ownedRoot){
  if (!ownedRoot || typeof ownedRoot !== "object"){
    await removeAllCharaItemPlacements();
    return;
  }
  const ownedKeys = new Set();
  for (const [groupKey, items] of Object.entries(ownedRoot)){
    if (!items || typeof items !== "object") continue;
    for (const itemId of Object.keys(items)){
      ownedKeys.add(`${groupKey}::${itemId}`);
    }
  }
  if (!ownedKeys.size){
    await removeAllCharaItemPlacements();
    return;
  }
  const placedKeys = Object.keys(charaItemPlacements || {});
  for (const itemKey of placedKeys){
    if (!ownedKeys.has(itemKey)){
      await removeCharaItemPlacement(itemKey);
    }
  }
}


function renderCharaItems(){
  renderCharaItemsToStage(inventoryCharaStack, { forceNeckBase: true, forceHandsBase: true });
  renderCharaItemsToStage(lessonCharaStack);
}
function renderCharaItemsToStage(stackEl, { forceNeckBase = false, forceHandsBase = false } = {}){
  const saved = getSavedChara();
  const baseImage = saved ? getCharaImage(saved) : "";
  const items = getEffectiveCharaItems({ forceNeckBase, forceHandsBase });
  if (stackEl) renderCharaStack(stackEl, baseImage, items);
}


async function loadInventory(){
  if (!inventoryMsg || !inventoryBody) return;
  if (!inventoryMsg || !inventoryBody) return false;
  if (!STUDENT.studentKey){
    inventoryMsg.textContent = "åå‰ã‚’å…¥åŠ›ã—ã¦ã‹ã‚‰ç¢ºèªã§ãã¾ã™ã€‚";
    inventoryBody.innerHTML = "";
    return true;
  }
  inventoryMsg.textContent = "èª­ã¿è¾¼ã¿ä¸­â€¦";
  inventoryBody.innerHTML = "";
  try{
    const ownedRoot = await dbGet(P.itemsOwnedRoot(STUDENT.studentKey));
    if (!ownedRoot || typeof ownedRoot !== "object"){
      inventoryMsg.textContent = "æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚";
      await removeAllCharaItemPlacements();
      return true;
    }
    const groups = Object.entries(ownedRoot);
    if (!groups.length){
      inventoryMsg.textContent = "æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚";
      await removeAllCharaItemPlacements();
      return true;
    }
    await removeUnownedCharaItemPlacements(ownedRoot);
    inventoryMsg.textContent = "";

    const itemsByClass = new Map();
    let totalItems = 0;

    for (const [groupKey, items] of groups){
      if (!items || typeof items !== "object") continue;
      for (const [itemId, item] of Object.entries(items)){
        const itemKey = `${groupKey}::${itemId}`;
        const itemClass = normalizeItemClass(item?.class);
       if (isItemClassHidden(itemClass)) continue;
        const displayClass = getItemClassGameClass(itemClass);
        if (!itemsByClass.has(displayClass)) itemsByClass.set(displayClass, []);
        itemsByClass.get(displayClass).push({ groupKey, itemId, item, itemClass, displayClass });
        totalItems += 1;
      }
    }
    if (!totalItems){
      inventoryMsg.textContent = "æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚";
      await removeAllCharaItemPlacements();
      return true;
    }
    const classOrder = getInventoryClassOrder(itemsByClass);
    for (const itemClass of classOrder){
      const entries = itemsByClass.get(itemClass);
      if (!entries || !entries.length) continue;
      const section = document.createElement("div");
      section.className = "inventoryGroup";
      const grid = document.createElement("div");
      grid.className = "inventoryGrid";
     const sortedEntries = [...entries].sort((a, b)=>{
        const aKey = `${a.groupKey}::${a.itemId}`;
        const bKey = `${b.groupKey}::${b.itemId}`;
        const aPlaced = Boolean(charaItemPlacements?.[aKey]);
        const bPlaced = Boolean(charaItemPlacements?.[bKey]);
        if (aPlaced !== bPlaced) return aPlaced ? -1 : 1;
        const aName = a.item?.name || "";
        const bName = b.item?.name || "";
        return String(aName).localeCompare(String(bName), "ja");
      });
      for (const entry of sortedEntries){
        const { groupKey, itemId, item, itemClass: rawClass, displayClass } = entry;
        const name = item?.name || "ã‚¢ã‚¤ãƒ†ãƒ ";
        const image = item?.image || "";
        const listImage = item?.listImage || "";
        const itemKey = `${groupKey}::${itemId}`;
        const card = document.createElement("div");
        card.className = "inventoryItem";
        card.dataset.itemKey = itemKey;
        card.dataset.itemClass = displayClass;
        const thumbOffset = getItemClassThumbOffset(rawClass);
        card.style.setProperty("--thumb-x", `${thumbOffset.x}%`);
        card.style.setProperty("--thumb-y", `${thumbOffset.y}%`);
        if (listImage){
          card.dataset.thumb = "full";
        }
        const thumbSrc = listImage || image;
        card.innerHTML = `
          <div class="inventoryItemThumb">
            <img src="${escapeHtml(thumbSrc)}" alt="${escapeHtml(name)}">
          </div>
        `;
        card.addEventListener("click", async ()=>{
          if (!image) return;
          const payload = {
            itemId,
            groupKey,
            name,
            image,
            image2: item?.image2 || "",
            class: rawClass,
            listImage
          };
          if (charaItemPlacements?.[itemKey]){
            delete charaItemPlacements[itemKey];
            renderCharaPreviewImmediate();
            updateInventoryPlacedState();
            persistCharaItemRemoval(itemKey);
            await ensureInitialClassPlacements();
            return;
          }
          const existingKeys = findPlacedItemKeysByClass(rawClass).filter((key)=> key !== itemKey);
          for (const existingKey of existingKeys){

            delete charaItemPlacements[existingKey];
            persistCharaItemRemoval(existingKey);
          }
          const placement = normalizeCharaItemPlacement(payload);
          charaItemPlacements[itemKey] = placement;
          renderCharaPreviewImmediate();
          updateInventoryPlacedState();
          persistCharaItemPlacement(itemKey, placement);
        });
        grid.appendChild(card);
      }
      section.innerHTML = `<h4>${escapeHtml(itemClass)}</h4>`;
      section.appendChild(grid);
      inventoryBody.appendChild(section);
    }
    updateInventoryPlacedState();
    return true;
  }catch(e){
    inventoryMsg.textContent = "èª­ã¿è¾¼ã¿å¤±æ•—";
    return true;
  }
}



/* ========= åˆæœŸï¼šåå‰å¾©å…ƒ ========= */
const savedName = localStorage.getItem(NAME_KEY);
if (savedName){
  stuName.value = savedName;
  STUDENT.studentKey = studentKeyFromName(savedName);
}
/* ========= åˆæœŸï¼šcharaå¾©å…ƒ ========= */
function normalizeChara(value){
  return charaSlotMap.has(value) ? value : "";
}
function getSavedChara(){
  const saved = normalizeChara(localStorage.getItem(CHARA_KEY) || "");
  if (!saved) localStorage.removeItem(CHARA_KEY);
  return saved;
}
function renderLessonChara(){
  if (!lessonChara || !lessonCharaStack) return;
  const saved = getSavedChara();
  if (!saved){
    lessonChara.style.display = "none";
    lessonCharaStack.innerHTML = "";
    return;
  }
  renderCharaStack(lessonCharaStack, getCharaImage(saved), getEffectiveCharaItems());
  lessonChara.style.display = (lessonListBox && lessonListBox.style.display !== "none") ? "flex" : "none";
  scheduleCharaItemsRender();
}

function applyCharaSelection(value, { save=false, collapse=false } = {}){
  const normalized = normalizeChara(value);
  charaButtons.forEach((btn)=>{
    const match = btn.dataset.chara === normalized;
    btn.classList.toggle("is-selected", match);
  });
  if (save && normalized) localStorage.setItem(CHARA_KEY, normalized);
  charaSelect.classList.toggle("single", collapse);
  renderLessonChara();
  renderInventoryChara();
  loadCharaItemPlacements().catch(()=>{});
}
function renderCharaSelect(){
  const saved = getSavedChara();
  if (saved){
    applyCharaSelection(saved, { save:false, collapse:true });
  } else {
    charaButtons.forEach(btn=>btn.classList.remove("is-selected"));
    charaSelect.classList.remove("single");
    renderLessonChara();
  }
}


function hideTopLoading(){
  if (!topLoading) return;
  topLoading.classList.add("is-hidden");
  // å®Œå…¨ã«æ¶ˆã—ã¦ãŠãï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãªã©ã®é‚ªé­”é˜²æ­¢ï¼‰
  setTimeout(()=>{ topLoading.style.display = "none"; }, 260);
}



// â˜…TOPç”»é¢ã®ã‚­ãƒ£ãƒ©ç”»åƒãŒã™ã¹ã¦èª­ã¿çµ‚ã‚ã£ãŸã‚‰ã€åå‰å…¥åŠ›ï¼†ãƒœã‚¿ãƒ³ã‚’å‡ºã™
function waitTopImagesThenShowUI(){
  if (!studentTop || !charaSelect){
    hideTopLoading();
    return;
  }

  const imgs = charaSelect.querySelectorAll("img");
  if (!imgs.length){
    // ç”»åƒãŒãªã„å ´åˆã¯ã™ãã«è¡¨ç¤º
    studentTop.classList.add("is-ready");
    hideTopLoading();
    return;
  }

  let remaining = imgs.length;

  const done = ()=>{
    remaining--;
    if (remaining <= 0){
      // ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ©ç”»åƒã® load / error ãŒçµ‚ã‚ã£ãŸ
      studentTop.classList.add("is-ready");
      hideTopLoading();
    }
  };

  imgs.forEach(img=>{
    // ã™ã§ã«èª­ã¿è¾¼ã¿æ¸ˆã¿ã®ã‚‚ã®ã¯å³ã‚«ã‚¦ãƒ³ãƒˆ
    if (img.complete){
      done();
    }else{
      img.addEventListener("load",  done, { once:true });
      img.addEventListener("error", done, { once:true });
    }
  });
}



function renderCharaSelectButtons(){
  if (!charaSelect) return;
  charaSelect.innerHTML = "";
  const slots = charaSlotList;
  charaButtons = [];
  for (const slot of slots){
    const btn = document.createElement("button");
    btn.className = "chara-btn";
    btn.type = "button";
    btn.dataset.chara = slot.key;
    btn.setAttribute("aria-label", `chara ${slot.key}`);
    const stack = document.createElement("div");
    stack.className = "chara-stack";
    renderCharaStack(stack, slot.image || getCharaImage(slot.key), getCharaSelectPreviewItems());
    btn.appendChild(stack);
    btn.addEventListener("click", ()=>{
      if (charaSelect.classList.contains("single")){
        charaSelect.classList.remove("single");
        return;
      }
      const value = btn.dataset.chara;
      applyCharaSelection(value, { save:true, collapse:true });
    });
    charaSelect.appendChild(btn);
    charaButtons.push(btn);
  }
  renderCharaSelect();
  waitTopImagesThenShowUI();

}



/* =========================
   â˜… å­¦å¹´ï¼ˆå¢—ãˆã‚‹ç‰ˆï¼‰
========================= */
function defaultGradeSettings(){
  return Array.from({length: DEFAULT_MAX_GRADE}, (_,i)=>({ id: i+1, label: String(i+1), enabled: true }));
}
function normalizeGradeSettings(obj){
  const base = defaultGradeSettings();
  if (!obj || typeof obj !== "object") return base;
  const out = [];
  for (const [k,v] of Object.entries(obj)){
    const id = Number(k);
    if (!Number.isFinite(id) || id < 1) continue;
    const label = String((v && typeof v === "object") ? (v.label ?? k) : (v ?? k)).trim() || String(id);
    const enabled = (v && typeof v === "object" && v.enabled === false) ? false : true;
    out.push({ id, label, enabled });
  }
  if (out.length === 0) return base;
  out.sort((a,b)=> a.id - b.id);
  return out;
}
function activeGradeIds(){
  return gradeSettings
    .filter(g=>g && g.enabled !== false && Number.isFinite(g.id))
    .map(g=>Number(g.id))
    .filter(g=>g>=1)
    .sort((a,b)=>a-b);
}
function gradeLabel(g){
  const cfg = gradeSettings.find(x=>Number(x.id) === Number(g));
  const lbl = String(cfg?.label ?? g).trim();
  return lbl || String(g);
}
function normalizeSelectedGrade(g){
  const active = activeGradeIds();
  if (!active.length) return 1;
  const n = Number(g);
  if (Number.isFinite(n) && active.includes(n)) return n;
  return active[0];
}

let gradeSettings = defaultGradeSettings();
let SELECTED_GRADE = normalizeSelectedGrade(Number(localStorage.getItem(GRADE_KEY) || "1"));
  
  function buildGradeButtons(){
  gradeFab.innerHTML = "";
  const active = activeGradeIds();
  if (!active.length) return;

  for (const cfg of gradeSettings){
    if (!cfg || cfg.enabled === false) continue;
    const g = Number(cfg.id);
    if (!Number.isFinite(g)) continue;

    const b = document.createElement("button");
    b.className = "gbtn";
    b.type = "button";
    b.textContent = gradeLabel(g);
    b.dataset.grade = String(g);
    b.onclick = async ()=>{
      SELECTED_GRADE = g;
      renderGradeButtons();
      if (IN_ROOM) await showLessonList();
    };
    gradeFab.appendChild(b);
  }
}
function renderGradeButtons(){
    SELECTED_GRADE = normalizeSelectedGrade(SELECTED_GRADE);
  [...gradeFab.querySelectorAll(".gbtn")].forEach(b=>{
    const g = Number(b.dataset.grade || "0");
    b.classList.toggle("active", g === SELECTED_GRADE);
  });
  localStorage.setItem(GRADE_KEY, String(SELECTED_GRADE));
}

  async function loadGradeSettings(){
  try{
    const raw = await dbGet(GRADE_SETTINGS_PATH);
    gradeSettings = normalizeGradeSettings(raw);
  }catch(e){
    gradeSettings = defaultGradeSettings();
  }
  SELECTED_GRADE = normalizeSelectedGrade(Number(localStorage.getItem(GRADE_KEY) || SELECTED_GRADE || 1));
  buildGradeButtons();
  renderGradeButtons();
}

/* ========= DBï¼ˆFirebaseï¼‰ ========= */
let STAGE_POOL = null;

async function enterStudent(name){
  const sk = STUDENT.studentKey;
  const path = P.students(sk);
  const now = nowTs();
  let existing = null;
  try{
    existing = await dbGet(path);
  }catch(e){
    existing = null;
  }

  await dbUpdate(path, { studentKey: sk, name, createdAt: now, lastSeenAt: now });
  if (!existing || !existing.createdAt){
    await ensureInitialItemsOwned();
  }
  try{
    setInterval(()=> dbUpdate(path, { lastSeenAt: nowTs() }).catch(()=>{}), 30000);
  }catch(e){}
}

async function ensureStagePool(grade, lesson, stage){
  grade = Number(grade)||1;
  lesson = String(lesson||"");
  stage = String(stage||"pre1");
  if (STAGE_POOL && STAGE_POOL.grade===grade && STAGE_POOL.lesson===lesson && STAGE_POOL.stage===stage) return STAGE_POOL;

  const sk = STUDENT.studentKey;
  const [wordsObj, progObj] = await Promise.all([
    dbGet(P.wordsStage(grade, lesson, stage)),
    dbGet(P.progressStage(sk, grade, lesson, stage))
  ]);

  const words = [];
  if (wordsObj && typeof wordsObj === "object"){
    for (const [wid, v] of Object.entries(wordsObj)){
      if (!v || typeof v !== "object") continue;
      const word = String(v.word ?? "").trim();
      const meaning = String(v.meaning ?? "").trim();
      const wrongsRaw = Array.isArray(v.wrongs) ? v.wrongs : [];
      const wrongs = wrongsRaw
        .map(x=>String(x||"").trim())
        .filter(text=>Boolean(text) && text !== meaning);
      if (!word || !meaning || wrongs.length < 1) continue;
const example = String(v.example ?? "").trim();
words.push({ id:String(wid), word, meaning, wrongs, example });
    }
  }

  STAGE_POOL = {
    grade, lesson, stage,
    words,
    prog: (progObj && typeof progObj==="object") ? progObj : {}
  };
  return STAGE_POOL;
}

function makeOptionsForWord(w){
  const meaning = String(w.meaning ?? "");
  const wrongs = Array.isArray(w.wrongs)
    ? w.wrongs.filter(text=>Boolean(text) && String(text) !== meaning)
    : [];
  const shuffled = wrongs.slice().sort(()=>Math.random()-0.5);
  const targetCount = Math.max(2, Math.min(1 + wrongs.length, 3));
  let opts = [meaning, ...shuffled.slice(0, Math.max(0, targetCount - 1))];

  if (opts.length < targetCount && STAGE_POOL && Array.isArray(STAGE_POOL.words)){
    const others = STAGE_POOL.words
      .filter(x=>x.id!==w.id)
      .map(x=>x.meaning)
      .filter(Boolean)
      .filter(text=>!opts.includes(String(text)));
    others.sort(()=>Math.random()-0.5);
    while (opts.length < targetCount && others.length) opts.push(others.pop());
  }

  opts = Array.from(new Set(opts.map(x=>String(x))));
  if (opts.length < targetCount && STAGE_POOL && Array.isArray(STAGE_POOL.words)){
    const fallback = STAGE_POOL.words
      .filter(x=>x.id!==w.id)
      .map(x=>x.meaning)
      .filter(Boolean)
      .filter(text=>!opts.includes(String(text)));
    fallback.sort(()=>Math.random()-0.5);
    while (opts.length < targetCount && fallback.length) opts.push(fallback.pop());
  }
  opts.sort(()=>Math.random()-0.5);
  return opts;
}

/* ========= APIäº’æ›ï¼ˆFirebaseå®Ÿè£…ï¼‰ ========= */
async function apiEnter(name){
  try{ await enterStudent(String(name||"")); return { ok:true }; }
  catch(e){ return { ok:false, error: (e && e.message) ? e.message : String(e) }; }
}

async function apiMenu(name){
  try{
    const sk = STUDENT.studentKey;
    const s = await dbGet(P.students(sk)) || {};
    const last = Number(s.lastGrade);
    return {
      ok:true,
      last_grade: Number.isFinite(last) && last>=1 ? last : null,
      grades: activeGradeIds()
    };
  }catch(e){
    return { ok:false, error:(e&&e.message)?e.message:String(e) };
  }
}

async function apiLessons(name, grade){
  try{
    const sk = STUDENT.studentKey;
    const g = Number(grade)||1;

    await dbUpdate(P.students(sk), { lastGrade:g, lastSeenAt: nowTs() }).catch(()=>{});

const [wordsGrade, bestGrade, progGrade, doneGrade] = await Promise.all([
  dbGet(P.wordsGrade(g)),
  dbGet(`bestProgress/${sk}/${g}`),     // âœ… è¿½åŠ ï¼šãƒ™ã‚¹ãƒˆï¼…
  dbGet(`progress/${sk}/${g}`),         // ï¼ˆäº’æ›ã®ãŸã‚æ®‹ã™ï¼šbestãŒç„¡ã„æ™‚ã ã‘æ—§æ–¹å¼ã§è¨ˆç®—ç”¨ï¼‰
  dbGet(`lessonProgress/${sk}/${g}`)
]);


    const wG = (wordsGrade && typeof wordsGrade==="object") ? wordsGrade : {};
const bG = (bestGrade && typeof bestGrade==="object") ? bestGrade : {};
const pG = (progGrade && typeof progGrade==="object") ? progGrade : {};
    const dG = (doneGrade && typeof doneGrade==="object") ? doneGrade : {};

    const lessons = Object.keys(wG).sort((a,b)=>{
      const na = parseFloat(String(a).replace(/[^0-9.]/g,""));
      const nb = parseFloat(String(b).replace(/[^0-9.]/g,""));
      if (Number.isFinite(na) && Number.isFinite(nb) && na!==nb) return na-nb;
      return String(a).localeCompare(String(b), "ja");
    });

function calc(lesson, stage){
  const stageObj = (wG[lesson] && wG[lesson][stage] && typeof wG[lesson][stage]==="object") ? wG[lesson][stage] : {};
  const wordIds = Object.keys(stageObj);
  const total = wordIds.length;

  // âœ… 1) ãƒ™ã‚¹ãƒˆï¼…ãŒã‚ã‚Œã°ãã‚Œã‚’æ¡ç”¨ï¼ˆã“ã‚ŒãŒæœ¬å‘½ï¼‰
  const bStage = (bG[lesson] && bG[lesson][stage] && typeof bG[lesson][stage] === "object")
    ? bG[lesson][stage]
    : null;

  const bestPct = bStage ? Number(bStage.bestPct) : null;
  const rateFromBest = (Number.isFinite(bestPct)) ? clamp(bestPct/100, 0, 1) : null;

  if (rateFromBest != null){
    const totalCount = total > 0 ? total : 100;

    return {
      total: totalCount,
      mastered: rateFromBest * totalCount,
      rate: rateFromBest
    };
  }

  // âœ… 2) bestProgressãŒã¾ã ç„¡ã„å¤ã„ãƒ‡ãƒ¼ã‚¿ç”¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæ—§ï¼šå˜èªmasteredè¨ˆç®—ï¼‰

  const pStage = (pG[lesson] && pG[lesson][stage] && typeof pG[lesson][stage]==="object") ? pG[lesson][stage] : {};
  let mastered = 0;
  for (const wid of wordIds){
    if (pStage[wid] && pStage[wid].mastered) mastered++;
  }
  const rate = total>0 ? (mastered/total) : null;
  return { total, mastered, rate };
}


    const outLessons = lessons.map(lesson=>{
      const pre1 = calc(lesson,"pre1");
      const pre2 = calc(lesson,"pre2");
      const review = calc(lesson,"review");

// âœ… pre1/pre2 ã®åˆç®—ã§èª²ã®é”æˆåº¦ã«ã™ã‚‹
const m1 = Number.isFinite(pre1.mastered) ? pre1.mastered : null;
const m2 = Number.isFinite(pre2.mastered) ? pre2.mastered : null;
const t1 = Number.isFinite(pre1.total) ? pre1.total : null;
const t2 = Number.isFinite(pre2.total) ? pre2.total : null;
let achieveRate = null;
if (Number.isFinite(m1) && Number.isFinite(m2) && Number.isFinite(t1) && Number.isFinite(t2) && (t1 + t2) > 0){
  achieveRate = clamp((m1 + m2) / (t1 + t2), 0, 1);
} else {
  const r1 = (pre1.rate != null) ? pre1.rate : 0;
  const r2 = (pre2.rate != null) ? pre2.rate : 0;
  achieveRate = clamp((r1 + r2) / 2, 0, 1);
}
      const done = dG[lesson] || {};
      const stage_status = {
        pre1: { completed_at: done.pre1?.completedAt || null },
        pre2: { completed_at: done.pre2?.completedAt || null },
        review:{ completed_at: done.review?.completedAt || null },
      };

      const stage_rates = {
        pre1: { rate: pre1.rate, mastered: pre1.mastered, total: pre1.total },
        pre2: { rate: pre2.rate, mastered: pre2.mastered, total: pre2.total },
        review:{ rate: review.rate, mastered: review.mastered, total: review.total },
      };

      return { lesson, achieveRate, stage_status, stage_rates };
    });

    return { ok:true, grade:g, lessons: outLessons };
  }catch(e){
    return { ok:false, error:(e&&e.message)?e.message:String(e) };
  }
}

async function apiQuestion(name, grade, lesson, stage){
  try{
    await ensureStagePool(grade, String(lesson||""), String(stage||"pre1"));
    if (!STAGE_POOL || !STAGE_POOL.words || STAGE_POOL.words.length===0){
      return { ok:false, error:"no_words" };
    }

    // âœ… å¸¸ã«å…¨å˜èªã‹ã‚‰å€™è£œ
    let candidates = STAGE_POOL.words;

    // âœ… ã“ã®ã‚¯ã‚¤ã‚ºã§ã€Œé”æˆæ¸ˆã¿ã€ã®å˜èªã¯å‡ºé¡Œã—ãªã„
    try{
      ensureSessionWordStats();
      if (typeof canAskWordId === "function" && SESSION){
        const okc = candidates.filter(w=>canAskWordId(w.id));
        candidates = okc;
      }
    }catch(e){}

    if (!candidates.length){
      return { ok:false, error:"session_done" };
    }


    const lastId = String(SESSION?.lastWordId ?? "");
    let pickList = candidates.slice();
    if (lastId && pickList.length > 1){
      const withoutLast = pickList.filter(w=>String(w.id ?? "") !== lastId);
      if (withoutLast.length) pickList = withoutLast;
    }

    if (pickList.length === 1 && lastId && String(pickList[0].id ?? "") === lastId){
      const fallbackId = pickFallbackWordId(lastId);
      if (fallbackId){
        const fallback = STAGE_POOL.words.find(w=>String(w.id ?? "") === fallbackId);
        if (fallback) pickList = [fallback];
      }
    }

    const w = pickList[Math.floor(Math.random()*pickList.length)];
    const options = makeOptionsForWord(w);

return {
  ok:true,
  word_id: w.id,
  word: w.word,
  options,
  correct: w.meaning,
  example: w.example || ""
};
  }catch(e){
    return { ok:false, error:(e&&e.message)?e.message:String(e) };
  }
}

async function apiAnswer(name, word_id, chosen){
  try{
    const sk = STUDENT.studentKey;
    const g = SELECTED_GRADE;
    const lesson = CURRENT.lesson;
    const stage = CURRENT.stage;

    await ensureStagePool(g, lesson, stage);
    const wid = String(word_id||"");
    const w = (STAGE_POOL && Array.isArray(STAGE_POOL.words))
      ? STAGE_POOL.words.find(x=>x.id===wid)
      : null;
    if (!w) return { ok:false, error:"word_not_found" };

    const correct = String(w.meaning ?? "");
    const c = String(chosen ?? "");
    const is_correct = (c === correct);

    const path = P.progressWord(sk, g, lesson, stage, wid);
    await runTransaction(ref(db, path), (cur)=>{
      const now = nowTs();
      const base = (cur && typeof cur === "object") ? cur : {
        correctCount: 0, wrongCount: 0, mastered: false, lastAt: 0
      };
      if (is_correct) base.correctCount = (base.correctCount||0) + 1;
      else base.wrongCount = (base.wrongCount||0) + 1;
      base.lastAt = now;
      if (is_correct) base.mastered = true;
      base.lastChosen = c;
      base.lastCorrect = correct;
      return base;
    });

    if (STAGE_POOL){
      STAGE_POOL.prog = STAGE_POOL.prog || {};
      const base = (STAGE_POOL.prog[wid] && typeof STAGE_POOL.prog[wid]==="object") ? STAGE_POOL.prog[wid] : {};
      base.mastered = base.mastered || is_correct;
      base.lastAt = nowTs();
      STAGE_POOL.prog[wid] = base;
    }

    return { ok:true, is_correct, correct, chosen: c };
  }catch(e){
    return { ok:false, error:(e&&e.message)?e.message:String(e) };
  }
}

async function apiLessonComplete(name, grade, lesson, stage){
  try{
    const sk = STUDENT.studentKey;
    const g = Number(grade)||SELECTED_GRADE;
    const l = String(lesson||"");
    const s = String(stage||"pre1");
    await dbSet(P.lessonStageDone(sk, g, l, s), { completedAt: nowTs() });
    return { ok:true };
  }catch(e){
    return { ok:false, error:(e&&e.message)?e.message:String(e) };
  }
}
async function apiSaveBestStage(name, grade, lesson, stage, pct){
  try{
    const sk = STUDENT.studentKey;
    const g = Number(grade) || SELECTED_GRADE;
    const l = String(lesson||"");
    const s = String(stage||"pre1");
    const p = clamp(Number(pct)||0, 0, 100);

    const path = P.bestStage(sk, g, l, s);

    await runTransaction(ref(db, path), (cur)=>{
      const now = nowTs();
      const base = (cur && typeof cur === "object") ? cur : {
        bestPct: 0,
        bestAt: 0,
        lastPct: 0,
        lastAt: 0,
        plays: 0
      };

      base.plays = (base.plays||0) + 1;
      base.lastPct = p;
      base.lastAt = now;

      const curBest = Number(base.bestPct||0);
      if (!Number.isFinite(curBest) || p > curBest){
        base.bestPct = p;
        base.bestAt = now;
      }
      return base;
    });

    return { ok:true };
  }catch(e){
    return { ok:false, error:(e&&e.message)?e.message:String(e) };
  }
}

/* ========= çŠ¶æ…‹ ========= */
let CURRENT = {
  name:"",
  grade:1,
  lessons:[],
  lesson:"",
  stage:"pre1",
  currentQ:null
};
let IN_ROOM = false;

/* ========= UI helper ========= */
function setStuStatus(text, ok=true){
  stuStatus.textContent = text;
  stuStatus.className = ok ? "muted ok" : "muted ng";
}

/* =========================
   âœ… è¿½åŠ ï¼špre1/pre2 40%æœªæº€ãªã‚‰ lowRateãƒãƒƒãƒ—
========================= */
const LOW_RATE_THRESHOLD = 0.40;  // â˜…ã“ã“ã‚’å¤‰æ›´ã™ã‚Œã°é–¾å€¤å¤‰æ›´
let _lowRatePending = null;       // { lesson, stage, meta }

function getStageRate01FromMeta(meta, stage){
  try{
    if (!meta || !meta.stageStats || !meta.stageStats[stage]) return null;
    const r = meta.stageStats[stage].rate;
    return (r != null) ? clamp(Number(r), 0, 1) : null;
  }catch(e){ return null; }
}

function closeLowRatePop(){
  if (!lowRateBack) return;
  lowRateBack.style.display = "none";
  if (lowRateList) lowRateList.innerHTML = "";
  _lowRatePending = null;
}

async function fetchRandomExamples(grade, lesson, stage, n=3){
  const obj = await dbGet(P.wordsStage(grade, lesson, stage));
  const arr = [];
  if (obj && typeof obj === "object"){
    for (const v of Object.values(obj)){
      if (!v || typeof v !== "object") continue;
      const word = String(v.word ?? "").trim();
      const meaning = String(v.meaning ?? "").trim();
      if (!word || !meaning) continue;
      arr.push({ word, meaning });
    }
  }
  if (!arr.length) return [];
  shuffleInPlace(arr);
  return arr.slice(0, Math.max(0, n|0));
}

async function openLowRatePop(lesson, stage, meta){
  _lowRatePending = { lesson:normLesson(lesson), stage:String(stage||"pre1"), meta: meta || null };


  if (lowRateList) lowRateList.innerHTML = "";

  let ex = [];
  try{
    ex = await fetchRandomExamples(SELECTED_GRADE, _lowRatePending.lesson, _lowRatePending.stage, 3);
  }catch(e){
    ex = [];
  }

  if (lowRateList){
    if (!ex.length){
      const li = document.createElement("li");
      li.innerHTML = `<span class="lrWord">ï¼ˆä¾‹ãªã—ï¼‰</span><span class="lrDash">-</span><span class="lrMean">å˜èªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</span>`;
      lowRateList.appendChild(li);
    } else {
      ex.forEach(({word, meaning})=>{
        const li = document.createElement("li");
        li.innerHTML =
          `<span class="lrWord">${escapeHtml(word)}</span>` +
          `<span class="lrDash">-</span>` +
          `<span class="lrMean">${escapeHtml(meaning)}</span>`;
        lowRateList.appendChild(li);
      });
    }
  }

  lowRateBack.style.display = "flex";
requestAnimationFrame(fitLowRateModalWidth);

}

/* å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ï¼ˆé–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ãªã—ï¼‰ */
lowRateBack.addEventListener("pointerdown", (e)=>{
  if (e.target === lowRateBack) closeLowRatePop();
}, { passive:true });
lowRateBack.querySelector(".modal")?.addEventListener("pointerdown", (e)=> e.stopPropagation(), { passive:true });

btnLowRateStart.onclick = ()=>{
  const p = _lowRatePending;
  closeLowRatePop();


  if (!p) return;
  // âœ… é€šå¸¸ã®é–‹å§‹å‡¦ç†ï¼ˆé–¾å€¤ãƒã‚§ãƒƒã‚¯ç„¡ã—ï¼‰ã¸
  startStageCore(p.stage, p.meta, p.lesson);
};
/* =========================
   âœ… è¿½åŠ ï¼šãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰ï¼ˆãŠã¼ãˆã‚‹ğŸ‘€ï¼‰
========================= */
const FLASH = {
  list: [],
  i: 0,
  timer: null,
  anim: false,
  dragging: false,
  startX: 0,
  lastDX: 0,
  suppressClick: false, // ã‚¹ãƒ¯ã‚¤ãƒ—å¾Œã®clickèª¤ç™ºç«é˜²æ­¢
  raf: 0,          // âœ…è¿½åŠ ï¼šãƒ‰ãƒ©ãƒƒã‚°æç”»ã‚’rAFã§é–“å¼•ã
  pendingDX: 0,    // âœ…è¿½åŠ ï¼šæ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã«åæ˜ ã™ã‚‹dx
  lastCountedIndex: -1,
  maskStep: -1,
};
const FLASH_PAGE_SIZE = 6;

function flashApplyDrag(){
  FLASH.raf = 0;
  const dx = FLASH.pendingDX;
  const limited = Math.max(-160, Math.min(160, dx));
  flashCard.style.transform = `translate3d(${limited}px,0,0)`;
}
function flashCancelRAF(){
  if (FLASH.raf){
    cancelAnimationFrame(FLASH.raf);
    FLASH.raf = 0;
  }
}


function clearFlashTimer(){
  if (FLASH.timer){
    clearTimeout(FLASH.timer);
    FLASH.timer = null;
  }
}

function getFlashMaskRows(){
  if (!flashList) return [];
  return Array.from(flashList.querySelectorAll(".flashRow"))
    .filter((row)=> !row.classList.contains("is-empty"));
}

function applyFlashMasking(){
  const rows = getFlashMaskRows();
  const total = rows.length;
  rows.forEach((row, index)=>{
    const word = row.querySelector(".flashWord");
    if (!word) return;
    const shouldMask = (FLASH.maskStep >= 0) && (index >= FLASH.maskStep) && (index < total);
    word.classList.toggle("flashMasked", shouldMask);
  });
}

function updateFlashModeButton(){
  if (!flashModeUnified) return;
  const label = flashModeUnified.querySelector(".flashModeLabel");
  const total = getFlashMaskRows().length;
  const isAllOpen = total > 0 && FLASH.maskStep >= total;
  const active = FLASH.maskStep >= 0;
  flashModeUnified.classList.toggle("active", active);
  if (!label) return;
  if (isAllOpen){
    label.textContent = "ã‹ãã™";
    return;
  }
  label.textContent = active ? "æ¬¡ã®ã“ã¨ã°ã‚’è¦‹ã‚‹" : "ã‹ãã™";

}

function cycleFlashMasking(){
  const total = getFlashMaskRows().length;
  if (!total) return;
  if (FLASH.maskStep < 0){
    FLASH.maskStep = 0;
  } else {
    FLASH.maskStep += 1;
    if (FLASH.maskStep > total){
      FLASH.maskStep = 0;
    }
  }
  applyFlashMasking();
  updateFlashModeButton();
}


function closeFlash(){
  if (!flashBack) return;
  clearFlashTimer();
  FLASH.list = [];
  FLASH.i = 0;
  FLASH.anim = false;
  FLASH.dragging = false;
  FLASH.suppressClick = false;
  FLASH.lastCountedIndex = -1;
  FLASH.maskStep = -1;

  // âœ… é€”ä¸­çŠ¶æ…‹ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆï¼ˆã‚«ã‚¯ã¤ãé˜²æ­¢ï¼‰
  flashCard.classList.remove("flashInRight","flashOutLeft","flashOutRight","flashInLeft");
  flashCard.style.transform = "";
  flashCard.style.transition = "";

  flashBack.style.display = "none";
}


function renderFlashCard(){
  const n = FLASH.list.length;
  if (!n){
    if (flashList) flashList.innerHTML = "";
    flashPager.textContent = "0/0";
    return;
  }


  const totalPages = Math.max(1, Math.ceil(n / FLASH_PAGE_SIZE));
  const pageIndex = Math.max(0, Math.min(FLASH.i, totalPages - 1));
  FLASH.i = pageIndex;
  const startIndex = pageIndex * FLASH_PAGE_SIZE;
  const endIndex = startIndex + FLASH_PAGE_SIZE;
  const pageItems = FLASH.list.slice(startIndex, endIndex);

  if (flashList){
    flashList.innerHTML = "";
    for (let idx = 0; idx < FLASH_PAGE_SIZE; idx += 1){
      const entry = pageItems[idx];
      const row = document.createElement("div");
      row.className = "flashRow";
      const main = document.createElement("div");
      main.className = "flashMain";
      const meaning = document.createElement("div");
      meaning.className = "flashMeaning";
      const word = document.createElement("div");
      word.className = "flashWord";
      const example = document.createElement("div");
      example.className = "flashExampleLine";

      if (entry){
        meaning.textContent = entry.meaning || "";
        word.textContent = entry.word || "";
        const ex = String(entry.example ?? "").trim();
        example.textContent = ex;
        if (!ex){
          example.classList.add("is-empty");
        }
      } else {
        row.classList.add("is-empty");
        meaning.textContent = "";
        word.textContent = "";
        example.textContent = "";
        example.classList.add("is-empty");
      }

      main.appendChild(meaning);
      main.appendChild(word);
      row.appendChild(main);
      row.appendChild(example);
      flashList.appendChild(row);
    }
  }

  flashPager.textContent = `${pageIndex + 1}/${totalPages}`;
  noteFlashCardViewed(pageItems.length);
  requestAnimationFrame(fitFlashModalWidth);
  applyFlashMasking();
  updateFlashModeButton();

}
function noteFlashCardViewed(count){
  if (!FLASH.list.length) return;
  if (FLASH.i === FLASH.lastCountedIndex) return;
  FLASH.lastCountedIndex = FLASH.i;
  const safeCount = Math.max(0, Math.trunc(count || 0));
  if (safeCount) recordFlashViews(safeCount);
}




function flashGo(dir, withAnim=true, fromX=0){
  if (!FLASH.list.length) return;
  if (FLASH.anim) return;

  clearFlashTimer();

  const n = FLASH.list.length;
  const totalPages = Math.max(1, Math.ceil(n / FLASH_PAGE_SIZE));
  const nextIndex = (FLASH.i + dir + totalPages) % totalPages;

  if (!withAnim){
    FLASH.i = nextIndex;
    renderFlashCard();
    scheduleFlashAuto();
    return;
  }

  FLASH.anim = true;

  // âœ… outã‚¢ãƒ‹ãƒ¡é–‹å§‹ä½ç½®ã‚’ã€Œä»Šã®ä½ç½®(fromX)ã€ã«å›ºå®šï¼ˆæˆ»ã‚Š1ãƒ•ãƒ¬ãƒ¼ãƒ é˜²æ­¢ï¼‰
  const sx = Math.max(-160, Math.min(160, Number(fromX) || 0));
  flashCard.style.transition = ""; // â† "none" ã®ã¾ã¾ã ã¨ã‚¢ãƒ‹ãƒ¡ãŒå¤‰ã«ãªã‚‹ã®ã§è§£é™¤
  flashCard.style.setProperty("--flashFromX", `${sx}px`);
  flashCard.style.transform = `translate3d(${sx}px,0,0)`;

  const outClass = (dir > 0) ? "flashOutLeft"  : "flashOutRight";
  const inClass  = (dir > 0) ? "flashInRight"  : "flashInLeft";

  flashCard.classList.remove("flashInRight","flashOutLeft","flashOutRight","flashInLeft");
  void flashCard.offsetWidth;
  flashCard.classList.add(outClass);

  flashCard.addEventListener("animationend", ()=>{
    flashCard.classList.remove(outClass);

    // âœ… outãŒçµ‚ã‚ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆï¼ˆæ¬¡ã®inã«å¹²æ¸‰ã•ã›ãªã„ï¼‰
    flashCard.style.transform = "";
    flashCard.style.removeProperty("--flashFromX");

    FLASH.i = nextIndex;
    renderFlashCard();

    void flashCard.offsetWidth;
    flashCard.classList.add(inClass);

    flashCard.addEventListener("animationend", ()=>{
      flashCard.classList.remove(inClass);
      FLASH.anim = false;
  FLASH.lastCountedIndex = -1;
      scheduleFlashAuto();
    }, { once:true });

  }, { once:true });
}

function flashNext(withAnim=true){ flashGo(1, withAnim); }
function flashPrev(withAnim=true){ flashGo(-1, withAnim); }


async function openFlashCards(grade, lesson, stage){
  if (!flashBack) return;

  flashPager.textContent = "--/--";
  flashBack.style.display = "flex";
requestAnimationFrame(fitFlashModalWidth);
  FLASH.maskStep = -1;

  let list = [];
  try{
    const obj = await dbGet(P.wordsStage(grade, lesson, stage));
    if (obj && typeof obj === "object"){
      const entries = Object.entries(obj);
      entries.sort((a,b)=> String(a[0]).localeCompare(String(b[0]))); // å®‰å®šé †
      for (const [, v] of entries){
        if (!v || typeof v !== "object") continue;
        const word = String(v.word ?? "").trim();
        const meaning = String(v.meaning ?? "").trim();
        if (!word || !meaning) continue;
const example = String(v.example ?? "").trim(); // âœ…è¿½åŠ ï¼ˆDBã®exampleï¼‰
list.push({ word, meaning, example });
      }
    }
  }catch(e){
    list = [];
  }

  if (!list.length){
    FLASH.list = [{ word:"ï¼ˆãƒ‡ãƒ¼ã‚¿ãªã—ï¼‰", meaning:"å˜èªãŒã‚ã‚Šã¾ã›ã‚“" }];
  } else {
    FLASH.list = list;
  }

  FLASH.i = 0;
  FLASH.anim = false;
  renderFlashCard();
  scheduleFlashAuto();
}

/* âœ…ã‚«ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã®ãƒœã‚¿ãƒ³ä»¥å¤–ã¯å…¨ã¦å¤–æ‰±ã„ï¼ˆã‚¿ãƒƒãƒã§é–‰ã˜ã‚‹ï¼‰ */
flashBack.addEventListener("pointerdown", (e)=>{
  if (e.target.closest(".flashCard, .flashModeWrap")) return;
  closeFlash();
}, { passive:true });


/* å·¦ã‚¹ãƒ¯ã‚¤ãƒ—ã§æ¬¡ï¼ˆã‚«ãƒ¼ãƒ‰ä¸Šï¼‰ */
/* å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ï¼ˆå·¦=æ¬¡ / å³=æˆ»ã‚‹ï¼‰ */
flashCard.addEventListener("pointerdown", (e)=>{
  if (FLASH.anim) return;

  FLASH.dragging = true;
  FLASH.startX = e.clientX;
  FLASH.lastDX = 0;
  FLASH.pendingDX = 0;
  FLASH.suppressClick = false;

  clearFlashTimer();

  // âœ…ã“ã“é‡è¦ï¼šãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã¯ transition/ã‚¢ãƒ‹ãƒ¡ã‚’å®Œå…¨åœæ­¢
  flashCancelRAF();
  flashCard.classList.remove("flashInRight","flashOutLeft","flashOutRight","flashInLeft");
  flashCard.style.transition = "none";
  flashCard.style.transform = "translate3d(0,0,0)";

  try{ flashCard.setPointerCapture(e.pointerId); }catch(_){}

  // âœ…ãƒ–ãƒ©ã‚¦ã‚¶ã®ä½™è¨ˆãªå‡¦ç†ã‚’æ­¢ã‚ã‚‹ï¼ˆã‚«ã‚¯ã¤ãæ¸›ï¼‰
  e.preventDefault();
}, { passive:false });

flashCard.addEventListener("pointermove", (e)=>{
  if (!FLASH.dragging) return;

  const dx = e.clientX - FLASH.startX;
  FLASH.lastDX = dx;

  if (Math.abs(dx) > 8) FLASH.suppressClick = true;

  // âœ…rAFã§1ãƒ•ãƒ¬ãƒ¼ãƒ 1å›ã ã‘åæ˜ ï¼ˆmoveé€£æ‰“ã«ã‚ˆã‚‹è©°ã¾ã‚Šé˜²æ­¢ï¼‰
  FLASH.pendingDX = dx;
  if (!FLASH.raf){
    FLASH.raf = requestAnimationFrame(flashApplyDrag);
  }

  e.preventDefault();
}, { passive:false });

flashCard.addEventListener("pointerup", (e)=>{
  if (!FLASH.dragging) return;
  FLASH.dragging = false;

  flashCancelRAF();

  const dx = FLASH.lastDX;
  const limited = Math.max(-160, Math.min(160, dx));

  // âœ…ã“ã“ã§æœ€çµ‚ä½ç½®ã‚’ç¢ºå®šï¼ˆrAFæœªåæ˜ ã®æœ€å¾Œã®dxã‚’åæ˜ ï¼‰
  flashCard.style.transition = ""; // ã„ã£ãŸã‚“è§£é™¤
  flashCard.style.transform = `translate3d(${limited}px,0,0)`;

  // ã—ãã„å€¤
  if (dx < -45){
    // âœ…æˆç«‹ï¼š0ã«æˆ»ã•ãšã€ãã®ä½ç½®ã‹ã‚‰ out ã‚¢ãƒ‹ãƒ¡é–‹å§‹
    flashGo(1, true, limited);
  } else if (dx > 45){
    flashGo(-1, true, limited);
  } else {
    // âœ…ä¸æˆç«‹ã ã‘ã€ã‚¹ãƒ ãƒ¼ã‚ºã«å…ƒã¸æˆ»ã™
    flashCard.style.transition = "transform .14s ease";
    flashCard.style.transform = "translate3d(0,0,0)";
    setTimeout(()=>{ flashCard.style.transition = ""; }, 160);
    scheduleFlashAuto();
  }

  try{ flashCard.releasePointerCapture(e.pointerId); }catch(_){}
  e.preventDefault();
}, { passive:false });

flashCard.addEventListener("pointercancel", (e)=>{
  if (!FLASH.dragging) return;
  FLASH.dragging = false;

  flashCancelRAF();

  flashCard.style.transition = "transform .14s ease";
  flashCard.style.transform = "translate3d(0,0,0)";
  setTimeout(()=>{ flashCard.style.transition = ""; }, 160);

  scheduleFlashAuto();

  try{ flashCard.releasePointerCapture(e.pointerId); }catch(_){}
  e.preventDefault();
}, { passive:false });

/* âœ… ã‚¯ãƒªãƒƒã‚¯ã§ã‚‚ã‚ãã‚‹ï¼ˆå·¦å´ã‚¿ãƒƒãƒ—=æˆ»ã‚‹ / å³å´ã‚¿ãƒƒãƒ—=æ¬¡ï¼‰ */
flashCard.addEventListener("click", (e)=>{
  if (FLASH.anim) return;
  if (FLASH.dragging) return;

  // ã‚¹ãƒ¯ã‚¤ãƒ—å¾Œã®clickèª¤ç™ºç«ã‚’ç„¡è¦–
  if (FLASH.suppressClick){
    FLASH.suppressClick = false;
    return;
  }

  clearFlashTimer();

  const rect = flashCard.getBoundingClientRect();
  const x = e.clientX - rect.left;
  if (x < rect.width * 0.45){
    flashPrev(true);
  } else {
    flashNext(true);
  }
});

flashModeUnified?.addEventListener("click", ()=>{
  cycleFlashMasking();
});


/* âœ… lowRateã®ã€ŒãŠã¼ãˆã‚‹ğŸ‘€ã€ï¼šãã® lesson/stage ã®å…¨å˜èªãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰ã‚’é–‹ã */
btnLowRateMem.onclick = async ()=>{
  const p = _lowRatePending;
  closeLowRatePop();
  if (!p) return;
  await openFlashCards(SELECTED_GRADE, p.lesson, p.stage);
};


/* =========================
   âœ… å¤‰æ›´ç‚¹ï¼ˆreviewé»’ç‰ã®æŒ™å‹•ï¼‰
========================= */
let QUIZ_REVIEW_BALLS_FROZEN = false;     // ã‚¯ã‚¤ã‚ºä¸­ãƒ•ãƒªãƒ¼ã‚º
let QUIZ_REVIEW_BALLS_START_COUNT = 0;    // é–‹å§‹æ™‚ã®ç‰æ•°
let QUIZ_REVIEW_FINALIZING = false;       // äºŒé‡å®Ÿè¡Œé˜²æ­¢

function isQuizVisible(){ return quizBox && quizBox.style.display !== "none"; }
function isReviewNow(){ return (CURRENT.stage === "review"); }

function freezeReviewBallsStart(){
  if (!isReviewNow()) return;
  QUIZ_REVIEW_BALLS_FROZEN = true;
  QUIZ_REVIEW_FINALIZING = false;

  // é–‹å§‹æ™‚ã®ç‰æ•°ã‚’ã€Œä»Šã®DBåæ˜ æ¸ˆã¿lessonä¸€è¦§ã€ã‹ã‚‰è¨ˆç®—
  QUIZ_REVIEW_BALLS_START_COUNT = getReviewBallCountForLesson(CURRENT.lesson);

  const key = `${CURRENT.name}|${SELECTED_GRADE}|${normLesson(CURRENT.lesson)}`;
  _quizReviewBallPrev.set(key, QUIZ_REVIEW_BALLS_START_COUNT);

  // ã¾ãšã¯â€œé™æ­¢è¡¨ç¤ºâ€ï¼ˆè½ã¨ã•ãªã„ï¼‰
  renderQuizReviewBalls(CURRENT.lesson, false, QUIZ_REVIEW_BALLS_START_COUNT);
}

function fitLowRateModalWidth(){
  if (!lowRateBack) return;
  if (lowRateBack.style.display === "none") return;

  const modal = lowRateBack.querySelector(".modal");
  if (!modal) return;

  // ã„ã£ãŸã‚“è‡ªç„¶å¹…ã«æˆ»ã™ï¼ˆæ¸¬å®šã®ãŸã‚ï¼‰
  modal.style.width = "auto";

  const maxW = Math.min(window.innerWidth * 0.92, 520);
  const minW = 260;

  let maxContentW = 0;

  const targets = [
    modal.querySelector(".lrExampleLabel"),
    ...modal.querySelectorAll("#lowRateList li"),
    ...modal.querySelectorAll(".lrBtns button"),
  ].filter(Boolean);

  for (const el of targets){
    // scrollWidth = æŠ˜ã‚Šè¿”ã—å‰æã˜ã‚ƒãªã„ã€Œå®Ÿã‚³ãƒ³ãƒ†ãƒ³ãƒ„å¹…ã€ã‚’å–ã‚Šã‚„ã™ã„
    maxContentW = Math.max(maxContentW, el.scrollWidth || 0);
  }

  const cs = getComputedStyle(modal);
  const pad =
    (parseFloat(cs.paddingLeft) || 0) +
    (parseFloat(cs.paddingRight) || 0);
  const border =
    (parseFloat(cs.borderLeftWidth) || 0) +
    (parseFloat(cs.borderRightWidth) || 0);

  let w = maxContentW + pad + border + 2; // ã¡ã‚‡ã„ä½™ç™½
  w = Math.max(w, minW);
  w = Math.min(w, maxW);

  modal.style.width = `${Math.round(w)}px`;
}

// âœ… ç”»é¢å›è»¢/ãƒªã‚µã‚¤ã‚ºã§ã‚‚è¿½å¾“
window.addEventListener("resize", ()=>{
  if (lowRateBack && lowRateBack.style.display === "flex"){
    requestAnimationFrame(fitLowRateModalWidth);
  }
  if (sessionBack && sessionBack.style.display === "flex"){
    requestAnimationFrame(fitSessionModalWidth);
  }
  if (flashBack && flashBack.style.display === "flex"){
    requestAnimationFrame(fitFlashModalWidth);
  }
  // âœ… reviewè¡¨ç¤ºã®è¿½å¾“ï¼ˆç¸®å°ï¼†ä¾‹æ–‡ä½ç½®ï¼‰
  if (quizBox && quizBox.style.display !== "none" && CURRENT.stage === "review"){
    requestAnimationFrame(applyReviewPromptLayout);
  }
  if (lessonListBox && lessonListBox.style.display !== "none"){
    requestAnimationFrame(syncAsaCircleSize);
  }
});
function fitSessionModalWidth(){
  if (!sessionBack) return;
  if (sessionBack.style.display === "none") return;

  const modal = sessionBack.querySelector(".modal");
  if (!modal) return;

  // ã„ã£ãŸã‚“è‡ªç„¶å¹…ã«æˆ»ã™ï¼ˆæ¸¬å®šã®ãŸã‚ï¼‰
  modal.style.width = "auto";

  const maxW = Math.min(window.innerWidth * 0.92, 520);
  const minW = 260;

  let maxContentW = 0;

  const targets = [
    modal.querySelector(".line1"),
    modal.querySelector(".line2"),
    modal.querySelector(".line3"),
    ...modal.querySelectorAll("#wrongList li .w"),
    ...modal.querySelectorAll("#wrongList li .m"),
    modal.querySelector("#btnSessionClose"),
  ].filter(Boolean);

  for (const el of targets){
    maxContentW = Math.max(maxContentW, el.scrollWidth || 0);
  }

  const cs = getComputedStyle(modal);
  const pad =
    (parseFloat(cs.paddingLeft) || 0) +
    (parseFloat(cs.paddingRight) || 0);
  const border =
    (parseFloat(cs.borderLeftWidth) || 0) +
    (parseFloat(cs.borderRightWidth) || 0);

  let w = maxContentW + pad + border + 2; // ã¡ã‚‡ã„ä½™ç™½
  w = Math.max(w, minW);
  w = Math.min(w, maxW);

  modal.style.width = `${Math.round(w)}px`;
}

function fitFlashModalWidth(){
  if (!flashBack) return;
  if (flashBack.style.display === "none") return;

  const modal = flashBack.querySelector(".flashModal");
  if (!modal) return;

  // æ¸¬å®šã®ãŸã‚ä¸€æ—¦auto
  modal.style.width = "auto";

  const maxW = Math.min(window.innerWidth * 0.92, 520);
  const minW = 260;

  let maxContentW = 0;
const targets = [flashList, flashPager].filter(Boolean); 
 for (const el of targets){
    maxContentW = Math.max(maxContentW, el.scrollWidth || 0);
  }

  // ä½™ç™½ã¯ã€Œã‚«ãƒ¼ãƒ‰å´ã€ã®padding/borderã‚’åŠ å‘³ï¼ˆlowRate/sessionã¨åŒã˜è€ƒãˆæ–¹ï¼‰
  const cs = getComputedStyle(flashCard);
  const pad =
    (parseFloat(cs.paddingLeft) || 0) +
    (parseFloat(cs.paddingRight) || 0);
  const border =
    (parseFloat(cs.borderLeftWidth) || 0) +
    (parseFloat(cs.borderRightWidth) || 0);

  let w = maxContentW + pad + border + 2;
  w = Math.max(w, minW);
  w = Math.min(w, maxW);

  modal.style.width = `${Math.round(w)}px`;
}



/* =========================
   âœ… reviewçµæœè¡¨ç¤ºå¾…ã¡ï¼ˆè½ä¸‹å®Œäº†â†’2ç§’ï¼‰
========================= */
let _reviewFinalizeToken = 0;
let _reviewResultTimer = null;
let _reviewResultFallbackTimer = null;

function clearReviewResultWait(){
  if (_reviewResultTimer){ clearTimeout(_reviewResultTimer); _reviewResultTimer = null; }
  if (_reviewResultFallbackTimer){ clearTimeout(_reviewResultFallbackTimer); _reviewResultFallbackTimer = null; }
  _reviewFinalizeToken++;
}

function scheduleOpenSessionResultAfterReviewBalls(prevCount, nextCount){
  clearReviewResultWait();
  const token = _reviewFinalizeToken;

  const stillValid = ()=>{
    if (token !== _reviewFinalizeToken) return false;
    if (!SESSION) return false;
    if (CURRENT.stage !== "review") return false;
    if (!quizBox || quizBox.style.display === "none") return false;
    return true;
  };

  const openAfter2s = ()=>{
    if (!stillValid()) return;
    _reviewResultTimer = setTimeout(()=>{
      if (!stillValid()) return;
      openSessionResult();
    }, 200);
  };

  // æ–°è¦è½ä¸‹ãªã—ï¼ã€Œå…¨éƒ¨è½ã¡ãŸã€æ‰±ã„ â†’ 2ç§’å¾Œã«è¡¨ç¤º
  if (!(nextCount > prevCount)){
    openAfter2s();
    return;
  }

  const drops = reviewBallSvg ? reviewBallSvg.querySelectorAll(".reviewBall.drop") : null;
  const lastDrop = (drops && drops.length) ? drops[drops.length - 1] : null;

  let finished = false;
  const finish = ()=>{
    if (finished) return;
    finished = true;
    openAfter2s();
  };

  if (lastDrop){
    lastDrop.addEventListener("animationend", finish, { once:true });

    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šdrop(0.62s) + ãƒ‡ã‚£ãƒ¬ã‚¤(90ms*(æ–°è¦æ•°-1)) + ä½™è£•
    const newN = nextCount - prevCount;
    const fallbackMs = Math.max(0, (newN - 1) * 90) + 620 + 120;
    _reviewResultFallbackTimer = setTimeout(finish, fallbackMs);
  } else {
    openAfter2s();
  }
}

async function finalizeReviewBallsAndShowResult(){
  if (!isReviewNow()) { openSessionResult(); return; }
  if (QUIZ_REVIEW_FINALIZING) return;
  QUIZ_REVIEW_FINALIZING = true;

  clearReviewResultWait();

  // ãƒ•ãƒªãƒ¼ã‚ºè§£é™¤ï¼ˆã“ã“ã‹ã‚‰å…ˆã¯æ›´æ–°OKï¼‰
  QUIZ_REVIEW_BALLS_FROZEN = false;

  const prev = QUIZ_REVIEW_BALLS_START_COUNT;
  const lesson = CURRENT.lesson;

  // ã€Œæœ€å¾Œã®å•é¡ŒãŒçµ‚ã‚ã£ãŸç¬é–“ã€ã«é”æˆç‡ã‚’å†å–å¾—ã—ã¦ç‰æ•°æ±ºå®š
  try{
    await refreshLessons(); // DBã®æœ€æ–°ã‚’èª­ã¿ã€review%ã‚’ç¢ºå®š
  }catch(e){}

  const next = getReviewBallCountForLesson(lesson);

  // å¢—ãˆãŸåˆ†ã ã‘è½ä¸‹ã•ã›ã‚‹ï¼ˆæ¸›ã£ãŸã‚‰å˜ã«æç”»ãŒæ¸›ã‚‹ï¼‰
  renderQuizReviewBalls(lesson, (next > prev), prev);

  // âœ… è½ä¸‹ãŒå…¨éƒ¨çµ‚ã‚ã£ã¦ã‹ã‚‰2ç§’å¾Œã«çµæœè¡¨ç¤º
  scheduleOpenSessionResultAfterReviewBalls(prev, next);
}

/* ========= ç”»é¢è¡¨ç¤º ========= */
function showNameScreen(){
  IN_ROOM = false;

  studentTop.style.display = "";
  charaSelect.style.display = "flex";
  renderCharaSelect();
  lessonListBox.style.display = "none";
  quizBox.style.display = "none";
  renderLessonChara();
  renderAsaPop();

  backFab.style.display = "none";
  gradeFab.style.display = "none";
  qTimer.style.display = "none";

  document.body.classList.remove("lesson-bg","quiz-bg");
  closeStagePop();
  closeSessionResult();
  closeLowRatePop();

  stopQuizWaveLoop();

  // âœ… reviewãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å¿µã®ãŸã‚éè¡¨ç¤º
  if (reviewBallSvg) reviewBallSvg.style.display = "none";

  // âœ… ãƒ•ãƒªãƒ¼ã‚ºè§£é™¤
  QUIZ_REVIEW_BALLS_FROZEN = false;
  QUIZ_REVIEW_FINALIZING = false;

  // âœ… reviewçµæœå¾…ã¡ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  clearReviewResultWait();
}

async function showLessonList(){
  IN_ROOM = true;

  studentTop.style.display = "none";
  charaSelect.style.display = "none";
  lessonListBox.style.display = "";
  quizBox.style.display = "none";
  renderLessonChara();
  renderAsaPop();
  backFab.style.display = "flex"; /* âœ… å³ä¸‹â†» */
  gradeFab.style.display = "flex";
  qTimer.style.display = "none";

  document.body.classList.add("lesson-bg");
  document.body.classList.remove("quiz-bg");

  if (_lastLessonTiles.length){
    drawLessonTrapezoids(false);
  }
  const prefetched = _lessonPrefetchPromise;
  if (prefetched){
    await prefetched;
  } else {
    await refreshLessons();
  }

  closeStagePop();
  closeSessionResult();
  closeLowRatePop();

  stopQuizWaveLoop();

  // âœ… reviewãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å¿µã®ãŸã‚éè¡¨ç¤º
  if (reviewBallSvg) reviewBallSvg.style.display = "none";

  // âœ… ãƒ•ãƒªãƒ¼ã‚ºè§£é™¤
  QUIZ_REVIEW_BALLS_FROZEN = false;
  QUIZ_REVIEW_FINALIZING = false;

  // âœ… reviewçµæœå¾…ã¡ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  clearReviewResultWait();
}

function showQuiz(){
  IN_ROOM = true;

  studentTop.style.display = "none";
  charaSelect.style.display = "none";
  lessonListBox.style.display = "none";
  quizBox.style.display = "";
  renderLessonChara();
  renderAsaPop();

  backFab.style.display = "flex"; /* âœ… å³ä¸‹â†» */
  gradeFab.style.display = "none";
  qTimer.style.display = "";

  document.body.classList.add("quiz-bg");
  document.body.classList.remove("lesson-bg");

  closeStagePop();
  closeSessionResult();
  closeLowRatePop();

  /* âœ… æ³¢ã¯â€œèƒŒæ™¯â€ï¼šã‚¯ã‚¤ã‚ºå‡¦ç†ã‚’æ­¢ã‚ãªã„ï¼ˆä½FPSã§å›ã™ã ã‘ï¼‰ */
  startQuizWaveLoop();

  setReviewVisualMode();

  // âœ… reviewãªã‚‰ã€Œé–‹å§‹æ™‚ç‚¹ã®ç‰æ•°ã€ã§é™æ­¢è¡¨ç¤ºï¼ˆã‚¯ã‚¤ã‚ºä¸­ã«è½ã¨ã•ãªã„ï¼‰
  if (CURRENT.stage === "review"){
    const key = `${CURRENT.name}|${SELECTED_GRADE}|${normLesson(CURRENT.lesson)}`;
    const prev = _quizReviewBallPrev.get(key) ?? getReviewBallCountForLesson(CURRENT.lesson);
    renderQuizReviewBalls(CURRENT.lesson, false, prev);
  }
}

/* âœ… å³ä¸‹â†»ã®æŒ™å‹•ï¼šã‚¯ã‚¤ã‚ºâ†’èª²é¸æŠ / èª²é¸æŠâ†’åå‰ */
backFab.onclick = async ()=>{
  if (inventoryBack && inventoryBack.style.display !== "none"){
    closeInventory();
    await showLessonList();
    return;
  }
  setStuStatus("", true);
  stopQuestionTimer();
  resetPrefetch();
  closeSessionResult();
  closeLowRatePop();

  // âœ… reviewçµæœå¾…ã¡ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  clearReviewResultWait();

  if (quizBox.style.display !== "none"){
    await showLessonList();
  } else if (lessonListBox.style.display !== "none"){
    showNameScreen();
  }
};

/* ========= ä¾¿åˆ© ========= */
const NS = "http://www.w3.org/2000/svg";
function sEl(name){ return document.createElementNS(NS, name); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function toRate01(v){
  let r = Number(v);
  if (!Number.isFinite(r)) return null;
  if (r > 1.0001) r = r / 100;
  return clamp(r, 0, 1);
}
function pctText(rate01){
  if (!(rate01 >= 0)) return "--";
  return `${Math.round(rate01*100)}%`;
}
function shuffleInPlace(arr){
  for (let i=arr.length-1; i>0; i--){
    const j = Math.floor(Math.random() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function defer(fn){
  setTimeout(fn, 0);
}

/* =========================
   âœ… ã—ãšãè‰²ã‚’ãƒãƒ¼è‰²ã«åŒæœŸ
========================= */
function syncDropletColorToGauge(){
  const fill = getGaugeFill(CURRENT.name, SELECTED_GRADE, CURRENT.lesson) || "#000";
  document.documentElement.style.setProperty("--dropletFill", fill);
  document.documentElement.style.setProperty("--dropletAlpha", String(GAUGE_ALPHA));
}

/* ========= â˜…ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šstageåˆ¥ã®é”æˆç‡ ========= */
function readStageStats(x){
  const out = {
    pre1:{ rate:null, mastered:null, total:null },
    pre2:{ rate:null, mastered:null, total:null },
    review:{ rate:null, mastered:null, total:null },
  };

  const sr = x.stage_rates || x.stageRates || x.stage_rate || x.stageRate || null;
  if (sr && typeof sr === "object"){
    ["pre1","pre2","review"].forEach(s=>{
      const o = sr[s];
      if (o && typeof o === "object"){
        if (out[s].rate == null && o.rate != null) out[s].rate = toRate01(o.rate);
        if (out[s].mastered == null && o.mastered != null) out[s].mastered = Number(o.mastered);
        if (out[s].total == null && o.total != null) out[s].total = Number(o.total);
        if (out[s].mastered == null && o.done != null) out[s].mastered = Number(o.done);
        if (out[s].total == null && o.all != null) out[s].total = Number(o.all);
      }
    });
  }

  ["pre1","pre2","review"].forEach(s=>{
    const m = out[s].mastered, t = out[s].total;
    if (out[s].rate == null && Number.isFinite(m) && Number.isFinite(t) && t > 0){
      out[s].rate = clamp(m / t, 0, 1);
    }
  });

  let sumRate = null;
  const m1 = out.pre1.mastered, t1 = out.pre1.total;
  const m2 = out.pre2.mastered, t2 = out.pre2.total;
  if (Number.isFinite(m1) && Number.isFinite(t1) && Number.isFinite(m2) && Number.isFinite(t2) && (t1+t2) > 0){
    sumRate = clamp((m1+m2) / (t1+t2), 0, 1);
  } else {
    const r1 = out.pre1.rate, r2 = out.pre2.rate;
    if ((r1 != null) && (r2 != null)) sumRate = clamp((r1+r2)/2, 0, 1);
    else if (r1 != null) sumRate = r1;
    else if (r2 != null) sumRate = r2;
  }

  return { ...out, sum_pre1_pre2: { rate: sumRate } };
}

/* ========= lessons ========= */
let _lastLessonTiles = [];
let _refreshLessonsRunId = 0;
let _lessonPrefetchPromise = null;
function prefetchLessons(){
  if (!CURRENT.name) return null;
  if (_lessonPrefetchPromise) return _lessonPrefetchPromise;
  _lessonPrefetchPromise = refreshLessons()
    .catch(()=>{})
    .finally(()=>{ _lessonPrefetchPromise = null; });
  return _lessonPrefetchPromise;
}
async function refreshLessons(){
  const runId = ++_refreshLessonsRunId;
  const j = await apiLessons(CURRENT.name, SELECTED_GRADE);
  if (runId !== _refreshLessonsRunId) return j; // æœ€æ–°ã®å‘¼ã³å‡ºã—ã ã‘åæ˜ 

  if (!j.ok){
    setStuStatus(`èª²ã®å–å¾—å¤±æ•—ï¼š${j.error||"unknown"}`, false);
    CURRENT.lessons = [];
    _lastLessonTiles = [];
    drawLessonTrapezoids();
    return j;
  }

  CURRENT.grade = Number(j.grade || SELECTED_GRADE) || SELECTED_GRADE;
  CURRENT.lessons = Array.isArray(j.lessons) ? j.lessons : [];

  _lastLessonTiles = CURRENT.lessons.map(x=>{
    const lesson = normLesson(x.lesson ?? x.lesson_name ?? x.name ?? "");
    let r = Number(x.achieveRate ?? 0);
    if (!Number.isFinite(r)) r = 0;
    r = clamp(r, 0, 1);

    const st = x.stage_status || {};
    const pre1_done = (st.pre1 && st.pre1.completed_at) || null;
    const pre2_done = (st.pre2 && st.pre2.completed_at) || null;
    const review_done = (st.review && st.review.completed_at) || null;

    const doneAt = x.completed_at || null;
    const stageStats = readStageStats(x);

    return {
      lesson,
      achieveRate:r,
      doneAt,
      stageDone: { pre1: pre1_done, pre2: pre2_done, review: review_done },
      stageStats
    };
  });

  _lastLessonTiles.forEach(t=>{
    ensureGaugeColorIfNeeded(CURRENT.name, SELECTED_GRADE, t.lesson, t.achieveRate);
  });

  drawLessonTrapezoids(true); /* âœ… æˆ»ã£ãŸæ™‚ã¯â€œä¼¸ã³â€ã‚¢ãƒ‹ãƒ¡ */
  syncDropletColorToGauge();

  // âœ… reviewã‚¯ã‚¤ã‚ºä¸­ã¯é»’ç‰ã‚’ã€Œæ›´æ–°ã—ãªã„ã€
  if (isQuizVisible() && CURRENT.stage === "review"){
    if (!QUIZ_REVIEW_BALLS_FROZEN && !QUIZ_REVIEW_FINALIZING){
      const key = `${CURRENT.name}|${SELECTED_GRADE}|${normLesson(CURRENT.lesson)}`;
      const prev = _quizReviewBallPrev.get(key) ?? getReviewBallCountForLesson(CURRENT.lesson);
      renderQuizReviewBalls(CURRENT.lesson, false, prev);
    }
  }
 return j;
}

function stageLabel(s){
  if (s === "pre1") return "å˜èª1";
  if (s === "pre2") return "å˜èª2";
  if (s === "review") return "å¾©ç¿’";
  return s || "";
}

async function ensureLessonMetaForLowRate(lesson){
  const normalized = normLesson(lesson);
  if (_pendingLessonMeta && _pendingLessonMeta.stageStats) return _pendingLessonMeta;
  try{
    const j = await apiLessons(CURRENT.name, SELECTED_GRADE);
    if (!j.ok || !Array.isArray(j.lessons)) return _pendingLessonMeta;
    const target = j.lessons.find(x=>{
      const name = normLesson(x.lesson ?? x.lesson_name ?? x.name ?? "");
      return name === normalized;
    });
    if (!target) return _pendingLessonMeta;
    const st = target.stage_status || {};
    const stageStats = readStageStats(target);
    _pendingLessonMeta = {
      lesson: normalized,
      achieveRate: clamp(Number(target.achieveRate ?? 0), 0, 1),
      doneAt: target.completed_at || null,
      stageDone: {
        pre1: st.pre1?.completed_at || null,
        pre2: st.pre2?.completed_at || null,
        review: st.review?.completed_at || null,
      },
      stageStats,
    };
  }catch(e){}
  return _pendingLessonMeta;
}


/* =========================
   âœ… ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼ˆãã®å›ï¼‰ç®¡ç†
========================= */
let SESSION = null;

function getStageTotalFromMeta(meta, stage){
  if (!meta || !meta.stageStats || !meta.stageStats[stage]) return null;
  const t = meta.stageStats[stage].total;
  return Number.isFinite(Number(t)) ? Number(t) : null;
}
function computePlannedCount(meta, stage){
  const total = getStageTotalFromMeta(meta, stage);
  if (!Number.isFinite(total) || total <= 0){
    return null;
  }
  if (QUIZ_RULES.maxQuestions === "all") return total * Math.max(1, QUIZ_RULES.repeatPerWord|0);
  const n = Number(QUIZ_RULES.maxQuestions);
  if (!Number.isFinite(n) || n <= 0) return total * Math.max(1, QUIZ_RULES.repeatPerWord|0);
  return Math.min(total, Math.trunc(n)) * Math.max(1, QUIZ_RULES.repeatPerWord|0);
}
function startSession(lesson, stage, meta){
  SESSION = {
    key: `${CURRENT.name}|${SELECTED_GRADE}|${lesson}|${stage}|${Date.now()}`,
    lesson, stage,
    asked: 0,
    correct: 0,
    wrongs: [],
    totalWrongs: 0,
    wordStats: new Map(),
    wordIds: [],
    asaAwarded: false,
    itemAwarded: false,
    rewardPrepared: false,
    preparedReward: null,
  };
}
function endSessionIfNeeded(){
  if (!SESSION) return false;
  const ids = Array.isArray(SESSION.wordIds) ? SESSION.wordIds : [];
  if (!ids.length || !SESSION.wordStats) return false;

  const allAchieved = ids.every((id)=> SESSION.wordStats.get(id)?.achieved);
  if (allAchieved) return true;

  if (SESSION.totalWrongs >= QUIZ_SESSION_RULES.endTotalWrongs){
    return true;
  }
  return false;
}


function ensureSessionWordStats(){
  if (!SESSION || !STAGE_POOL || !Array.isArray(STAGE_POOL.words)) return;
  if (!SESSION.wordStats) SESSION.wordStats = new Map();
  const ids = STAGE_POOL.words.map(w=>String(w.id ?? ""));
  SESSION.wordIds = ids.filter(Boolean);
  SESSION.wordIds.forEach((id)=>{
    if (!SESSION.wordStats.has(id)){
      SESSION.wordStats.set(id, {
        shown: 0,
        correct: 0,
        fast: 0,
        wrongStreak: 0,
        achieved: false,
      });
    }
  });
}

function getSessionWordStats(wordId){
  if (!SESSION) return null;
  ensureSessionWordStats();
  if (!SESSION.wordStats) return null;
  const id = String(wordId ?? "");
  if (!id) return null;
  if (!SESSION.wordStats.has(id)){
    SESSION.wordStats.set(id, {
      shown: 0,
      correct: 0,
      fast: 0,
      wrongStreak: 0,
      achieved: false,
    });
  }
  return SESSION.wordStats.get(id);
}

function markWordShown(wordId){
  const stats = getSessionWordStats(wordId);
  if (!stats) return;
  stats.shown = (stats.shown || 0) + 1;
}

function applyWordAnswerStats(wordId, isCorrect, isFast){
  const stats = getSessionWordStats(wordId);
  if (!stats) return;
  if (isCorrect){
    stats.correct = (stats.correct || 0) + 1;
    if (isFast) stats.fast = (stats.fast || 0) + 1;
    stats.wrongStreak = 0;
  } else {
    stats.fast = 0;
    stats.wrongStreak = (stats.wrongStreak || 0) + 1;
  }
  if (stats.fast >= QUIZ_SESSION_RULES.masteredFastCount || stats.correct >= QUIZ_SESSION_RULES.masteredCorrectCount){
    stats.achieved = true;
  }
}

function applySessionAnswerStats({ wordId, word, correctText, chosen, isCorrect, isFast }){
  if (!SESSION) return;
  if (isCorrect){
    SESSION.correct += 1;
  } else {
    SESSION.totalWrongs += 1;
    SESSION.wrongs.push({ word: word || "", meaning: String(correctText || "") });
  }
  applyWordAnswerStats(wordId, isCorrect, isFast);
}

function pickFallbackWordId(excludeId){
  if (!SESSION || !STAGE_POOL || !Array.isArray(STAGE_POOL.words)) return null;
  ensureSessionWordStats();
  const exclude = String(excludeId ?? "");
  const candidates = STAGE_POOL.words
    .map(w=>({ id: String(w.id ?? ""), stats: SESSION.wordStats.get(String(w.id ?? "")) }))
    .filter(x=> x.id && x.id !== exclude);
  if (!candidates.length) return null;

  candidates.sort((a, b)=>{
    const sa = a.stats || {};
    const sb = b.stats || {};
    const aAch = sa.achieved ? 1 : 0;
    const bAch = sb.achieved ? 1 : 0;
    if (aAch !== bAch) return aAch - bAch;
    const aCorrect = sa.correct || 0;
    const bCorrect = sb.correct || 0;
    if (aCorrect !== bCorrect) return aCorrect - bCorrect;
    const aFast = sa.fast || 0;
    const bFast = sb.fast || 0;
    if (aFast !== bFast) return aFast - bFast;
    const aShown = sa.shown || 0;
    const bShown = sb.shown || 0;
    if (aShown !== bShown) return aShown - bShown;
    const aWrong = sa.wrongStreak || 0;
    const bWrong = sb.wrongStreak || 0;
    return bWrong - aWrong;
  });

  return candidates[0]?.id || null;
}


function openSessionResult(){
  if (!SESSION) return;

  const totalAsked = Math.max(1, SESSION.asked || 0);
  const pct = Math.round((SESSION.correct || 0) / totalAsked * 100);
  const delayModalForReward = pct >= 100;

  // âœ… ã¾ãšè¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
  if (sessionReward){
    sessionReward.textContent = "";
    sessionReward.style.display = "none";
  }
  if (wrongList){
    wrongList.innerHTML = "";
    wrongList.style.display = "none";
  }

  // âœ… ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆé–“é•ãˆãŸã“ã¨ã° â†’ GETï¼ï¼‰
  if (sessionTitleText){
    sessionTitleText.textContent = (pct >= 100) ? "ãŠã‚ã§ã¨ã†ğŸ‰" : "é–“é•ãˆãŸã“ã¨ã°";
  }else if (sessionTitle){

    sessionTitle.textContent = (pct >= 100) ? "ãŠã‚ã§ã¨ã†ğŸ‰" : "é–“é•ãˆãŸã“ã¨ã°";
  }
  if (sessionTitle){
    sessionTitle.classList.toggle("is-wrong", pct < 100);
  }
  if (sessionAsaValue){
    const gained = calcAsaFromPct(pct);
    sessionAsaValue.textContent = String(gained);
    if (sessionAsaGain){
      sessionAsaGain.style.display = gained > 0 ? "inline-flex" : "none";
    }
  }
  drawAsaCoinOn(sessionAsaCoin);


  // âœ… ãƒ™ã‚¹ãƒˆï¼…ã‚’DBã«ä¿å­˜ï¼ˆæœ€å¤§å€¤ã ã‘æ®‹ã™ï¼‰
  (async ()=>{
    try{
      await apiSaveBestStage(CURRENT.name, SELECTED_GRADE, SESSION.lesson, SESSION.stage, pct);
      // ãƒ™ã‚¹ãƒˆæ›´æ–°ãŒã‚ã‚Šå¾—ã‚‹ã®ã§ã€ä¸€è¦§å´ã®è¡¨ç¤ºã‚‚è¿½å¾“
      defer(()=> refreshLessons().catch(()=>{}));
    }catch(_){}
  })();

  // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸è¡¨ç¤º
  sessionPct.textContent = `${pct}%`;

  // ASAä»˜ä¸
  awardAsaForSession(pct).catch(()=>{});

  // âœ… ã‚¢ã‚¤ãƒ†ãƒ å ±é…¬ + é–“é•ã„ä¸€è¦§ã®æç”»
  (async ()=>{
    if (delayModalForReward){
      await prepareSessionReward().catch(()=>{});
    }
    let reward = null;
    try{
      reward = await awardItemForSession(pct);
    }catch(_){}

    if (pct >= 100){
      // ------- 100% ã®ã¨ãï¼šGETè¡¨ç¤ºï¼‹ã‚µãƒ ãƒã€é–“é•ã„ãƒªã‚¹ãƒˆéè¡¨ç¤º -------
      if (sessionReward){
        if (reward && reward.image){
          const name = reward.name || "ã‚¢ã‚¤ãƒ†ãƒ ";
          const imgSrc = reward.image;

          const itemClass = normalizeItemClass(reward.class);
          const isHidden = isItemClassHidden(itemClass);
          const displayClass = getItemClassGameClass(itemClass);
          const listImage = reward.listImage || "";
          const thumbSrc = listImage || imgSrc;
          const itemClassAttr = displayClass ? ` data-item-class="${escapeHtml(displayClass)}"` : "";
         const thumbAttr = listImage ? ' data-thumb="full"' : "";
         const thumbOffset = getItemClassThumbOffset(itemClass);
          const thumbStyle = ` style="--thumb-x:${thumbOffset.x}%;--thumb-y:${thumbOffset.y}%;"`;
          if (isHidden){
            sessionReward.textContent = `${reward.name || "ã‚¢ã‚¤ãƒ†ãƒ "} ã‚’GETï¼`;
          }else{
            sessionReward.innerHTML =
              `<div class="sessionRewardItem"${itemClassAttr}${thumbAttr}${thumbStyle}>
                 <div class="sessionRewardThumb">
                   <img src="${escapeHtml(thumbSrc)}" alt="${escapeHtml(name)}">
                 </div>
                 <div class="sessionRewardName">${escapeHtml(name)}</div>
               </div>`;
          }

        }else if (reward){
          // ç”»åƒãªã—ã ãŒåå‰ã¯ã‚ã‚‹å ´åˆ
          sessionReward.textContent = `${reward.name || "ã‚¢ã‚¤ãƒ†ãƒ "} ã‚’GETï¼`;
        }else{
          // ãã‚‚ãã‚‚æ–°è¦ã‚¢ã‚¤ãƒ†ãƒ ãŒç„¡ã‹ã£ãŸå ´åˆ
          sessionReward.textContent = "ã‚¢ã‚¤ãƒ†ãƒ ã¯å…¨éƒ¨é›†ã‚ã¾ã—ãŸï¼";
        }
        sessionReward.style.display = "block";
      }

      // âœ… é–“é•ã„ãƒªã‚¹ãƒˆã¯æ¶ˆã™ï¼ˆä¸‹ç·šã‚‚æ¶ˆãˆã‚‹ï¼‰
      if (wrongList){
        wrongList.style.display = "none";
      }
    }else{
      // ------- 100% ä»¥å¤–ï¼šé€šå¸¸ã©ãŠã‚Šã€Œé–“é•ãˆãŸã“ã¨ã°ã€ã‚’è¡¨ç¤º -------
      renderSessionWrongList();
    }

    requestAnimationFrame(fitSessionModalWidth);


    if (delayModalForReward){
      sessionBack.style.display = "flex";
      requestAnimationFrame(fitSessionModalWidth);
    }

  })();

  // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
  if (!delayModalForReward){
    sessionBack.style.display = "flex";
    requestAnimationFrame(fitSessionModalWidth);
  }
}

/* âœ… 100%ä»¥å¤–ã®ã¨ãã®ã€Œé–“é•ãˆãŸã“ã¨ã°ã€ãƒªã‚¹ãƒˆæç”» */
function fillBlankWithAnswer(question, answer){
  const q = String(question || "");
  const a = String(answer || "").trim();
  if (!q || !a) return { text: q, filled: false };

  const fullWidth = /ï¼ˆ\s*ï¼‰/;
  if (fullWidth.test(q)){
    return { text: q.replace(fullWidth, `ï¼ˆ ${a} ï¼‰`), filled: true };
  }

  const halfWidth = /\(\s*\)/;
  if (halfWidth.test(q)){
    return { text: q.replace(halfWidth, `( ${a} )`), filled: true };
  }

  return { text: q, filled: false };
}


function renderSessionWrongList(){
  if (!wrongList || !SESSION) return;

  const wrongs = Array.isArray(SESSION.wrongs) ? SESSION.wrongs : [];
  if (!wrongs.length){
    wrongList.style.display = "none";
    return;
  }

  wrongList.innerHTML = "";
  wrongList.style.display = "block";

  wrongs.forEach((w)=>{
    const li = document.createElement("li");
    const answer = w.correct || w.meaning || "";
    const filled = fillBlankWithAnswer(w.word || "", answer);


    const wordEl = document.createElement("div");
    wordEl.className = "w";
    wordEl.textContent = filled.text;

    const meanEl = document.createElement("div");
    meanEl.className = "m";

    const parts = [];
    if (!filled.filled && w.meaning) parts.push(w.meaning);
    if (!filled.filled && w.correct && w.correct !== w.meaning) parts.push(`ï¼ˆæ­£ï¼š${w.correct}ï¼‰`);

    meanEl.textContent = parts.join(" ");

    li.appendChild(wordEl);
    li.appendChild(meanEl);
    wrongList.appendChild(li);
  });
}



function closeSessionResult(){
  sessionBack.style.display = "none";
}
btnSessionClose.onclick = async ()=>{
  closeSessionResult();
  await showLessonList();
};
sessionBack.addEventListener("click", ()=>{ /* do nothing */ });
sessionBack.querySelector(".modal")?.addEventListener("click", (e)=> e.stopPropagation());


async function openInventory(){
  if (!inventoryBack) return;
  inventoryBack.style.display = "flex";
  if (gradeFab) gradeFab.style.display = "none";
  if (backFab) backFab.style.display = "flex";
  renderInventoryChara();
  await loadInitialItems().catch(()=>{});
  await loadCharaItemPlacements().catch(()=>{});
  await loadInventoryIfNeeded().catch(()=>{});
}
function closeInventory(){
  if (!inventoryBack) return;
  inventoryBack.style.display = "none";
  if (quizBox.style.display !== "none"){
    backFab.style.display = "flex";
    gradeFab.style.display = "none";
  } else if (lessonListBox.style.display !== "none"){
    backFab.style.display = "flex";
    gradeFab.style.display = "flex";
  } else {
    backFab.style.display = "none";
    gradeFab.style.display = "none";
  }
}
inventoryBack?.addEventListener("click", (e)=>{
  if (e.target === inventoryBack) closeInventory();
});
inventoryBack?.querySelector(".inventoryModal")?.addEventListener("click", (e)=> e.stopPropagation());

lessonChara?.addEventListener("click", ()=>{
  openInventory();
});

asaCircle?.addEventListener("click", (e)=>{
  e.stopPropagation();
  openShop();
});

shopClose?.addEventListener("click", closeShop);
shopBack?.addEventListener("click", (e)=>{
  if (e.target === shopBack) closeShop();
});
shopBack?.querySelector(".shopModal")?.addEventListener("click", (e)=> e.stopPropagation());
shopPurchaseBtn?.addEventListener("click", purchaseShopItem);
shopCancelBtn?.addEventListener("click", closeShopPurchase);
shopPurchaseBack?.addEventListener("click", (e)=>{
  if (e.target === shopPurchaseBack) closeShopPurchase();
});
shopPurchaseBack?.querySelector(".shopPurchaseModal")?.addEventListener("click", (e)=> e.stopPropagation());


// âœ… ï¼ˆâ€¦ï¼‰ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã«æ­£è§£ã‚’å·®ã—è¾¼ã¿è¡¨ç¤ºã™ã‚‹ï¼ˆè£…é£¾ä»˜ãï¼‰
function fillAnswerIntoParensHtml(word, answer){
  const ans = escapeHtml(String(answer ?? ""));
  const base = escapeHtml(String(word ?? ""));
  return base.replace(/ï¼ˆ[^ï¼‰]*ï¼‰/g, `<span class="wrongParen">ï¼ˆ</span><span class="wrongParenAnswer">${ans}</span><span class="wrongParen">ï¼‰</span>`);
}
/* =========================
   âœ… reviewï¼šå•é¡Œã‚’æ”¹è¡Œã—ãªã„ï¼†è‡ªå‹•ç¸®å°
   âœ… å•é¡Œã®ä¸‹ã«ä¾‹æ–‡ï¼ˆexampleï¼‰ã‚’è¡¨ç¤º
========================= */
const REVIEW_WORD_BASE_PX = (()=> {
  const root = document.documentElement;
  const v = getComputedStyle(root).getPropertyValue("--reviewWordMaxPx");
  const n = Number.parseInt(v, 10);
  return Number.isFinite(n) && n > 0 ? n : 30;
})();

const REVIEW_WORD_MIN_PX  = 18;

const REVIEW_OPTION_MIN_PX = 12;

function applyReviewOptionLayout(){
  if (!optGrid) return;

  const isReview = (CURRENT.stage === "review");
  const btns = [...optGrid.querySelectorAll(".optBtn")];
  if (!btns.length) return;

  if (!isReview){
    btns.forEach((btn)=>{
      btn.style.whiteSpace = "";
      btn.style.overflow = "";
      btn.style.textOverflow = "";
      btn.style.fontSize = "";
    });
    return;
  }

  const basePx = (()=> {
    const size = Number.parseFloat(getComputedStyle(btns[0]).fontSize || "16");
    return Number.isFinite(size) && size > 0 ? size : 16;
  })();

  btns.forEach((btn)=>{
    btn.style.whiteSpace = "nowrap";
    btn.style.overflow = "hidden";
    btn.style.textOverflow = "ellipsis";

    let fs = Math.round(basePx);
    btn.style.fontSize = `${fs}px`;

    while (fs > REVIEW_OPTION_MIN_PX && (btn.scrollWidth > btn.clientWidth + 1)){
      fs -= 1;
      btn.style.fontSize = `${fs}px`;
    }
  });
}

function positionQuizExampleUnderWord(){
  if (!quizStage || !quizWord || !quizExample) return;
  if (quizExample.style.display === "none") return;

  const stageRect = quizStage.getBoundingClientRect();
  const wordRect  = quizWord.getBoundingClientRect();

  const top = (wordRect.bottom - stageRect.top) + 10; // 10pxä¸‹ã«
  quizExample.style.top = `${Math.round(top)}px`;
}

function applyReviewPromptLayout(){
  if (!quizWord) return;

  const isReview = (CURRENT.stage === "review");

  // reset
  quizWord.classList.toggle("oneLine", isReview);

  if (!isReview){
    // é€šå¸¸ã¯å…ƒã®è¦‹ãŸç›®ã«æˆ»ã™
    quizWord.style.fontSize = "";
    quizWord.style.whiteSpace = "";
    quizWord.style.overflow = "";
    quizWord.style.textOverflow = "";

    if (quizExample){
      quizExample.textContent = "";
      quizExample.style.display = "none";
      quizExample.style.top = "";
    }
    return;
  }

  // reviewï¼š1è¡Œå›ºå®šï¼‹ç¸®å°
  quizWord.style.whiteSpace = "nowrap";
  quizWord.style.overflow = "hidden";
  quizWord.style.textOverflow = "ellipsis";

  // ã¾ãšãƒ™ãƒ¼ã‚¹ã‚µã‚¤ã‚ºã«æˆ»ã—ã¦ã‹ã‚‰æ¸¬å®š
  let fs = REVIEW_WORD_BASE_PX;
  quizWord.style.fontSize = `${fs}px`;

  // åã¾ã‚‹ã¾ã§ç¸®å°ï¼ˆscrollWidth > clientWidth ã®é–“ï¼‰
  // â€» +1 ã¯å°æ•°èª¤å·®ã®ä¿é™º
  while (fs > REVIEW_WORD_MIN_PX && (quizWord.scrollWidth > quizWord.clientWidth + 1)){
    fs -= 1;
    quizWord.style.fontSize = `${fs}px`;
  }

  // ä¾‹æ–‡
  const ex = String(CURRENT.currentQ?.example ?? "").trim();
  if (quizExample){
    if (ex){
      quizExample.textContent = ex;
      quizExample.style.display = "";
      // å•é¡Œã®ã‚µã‚¤ã‚ºãŒç¢ºå®šã—ã¦ã‹ã‚‰ä½ç½®åˆã‚ã›
      requestAnimationFrame(positionQuizExampleUnderWord);
    } else {
      quizExample.textContent = "";
      quizExample.style.display = "none";
    }
  }
  applyReviewOptionLayout();
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

/* ========= stageãƒãƒƒãƒ— ========= */
let _pendingLesson = "";
let _pendingLessonMeta = null;
let _stageTimer = null;

function closeStagePop(){
  stagePop.style.display = "none";
  _pendingLesson = "";
  _pendingLessonMeta = null;
  if (_stageTimer){ clearTimeout(_stageTimer); _stageTimer = null; }
}
function openStagePop(lesson, meta, anchorX, anchorY){
  lesson = normLesson(lesson);

  _pendingLesson = lesson;
  _pendingLessonMeta = meta || null;
  stagePopTitle.textContent = `${gradeLabel(SELECTED_GRADE)} / ${lesson}`;
  const hasInfo = !!(meta && meta.stageDone && (meta.stageDone.pre1 || meta.stageDone.pre2 || meta.stageDone.review));
  const pre1Done = hasInfo ? !!meta.stageDone.pre1 : null;
  const pre2Done = hasInfo ? !!meta.stageDone.pre2 : null;

  btnStagePre1.disabled = false;
  btnStagePre2.disabled = (hasInfo ? !pre1Done : false);
  btnStageReview.disabled = (hasInfo ? !pre2Done : false);

  const rect = lessonList.getBoundingClientRect();
  let x = anchorX;
  let y = anchorY;

  stagePop.style.display = "block";

  const popW = stagePop.offsetWidth || 240;
  const popH = stagePop.offsetHeight || 80;
  const pad = 10;

  x = Math.max(pad + popW/2, Math.min(rect.width - pad - popW/2, x));
  y = Math.max(pad, Math.min(rect.height - pad - popH, y));

  stagePop.style.left = `${x}px`;
  stagePop.style.top  = `${y}px`;

  if (_stageTimer){ clearTimeout(_stageTimer); }
  _stageTimer = setTimeout(closeStagePop, 5000);
}

/* âœ… é–‹å§‹å‡¦ç†ã®â€œæœ¬ä½“â€ï¼ˆé–¾å€¤ãƒã‚§ãƒƒã‚¯ãªã—ï¼‰ */
function startStageCore(stage, metaOverride=null, lessonOverride=null){
  const meta = metaOverride ?? _pendingLessonMeta;
  const lesson = normLesson(lessonOverride ?? _pendingLesson);

  if (!lesson) return;

  CURRENT.lesson = lesson;
  CURRENT.stage = stage;

  if (lessonInfo) lessonInfo.textContent = `${gradeLabel(SELECTED_GRADE)} / ${CURRENT.lesson}`;
  if (stageBadge){
    stageBadge.style.display = "";
    stageBadge.textContent = stageLabel(stage);
  }
  if (hint) hint.textContent = "";
  if (quizResult) quizResult.textContent = "";
  CURRENT.currentQ = null;

  startSession(CURRENT.lesson, CURRENT.stage, meta || null);

  // âœ… reviewãªã‚‰ã€Œé–‹å§‹æ™‚ç‚¹ã§ç‰æ•°å›ºå®šï¼ˆãƒ•ãƒªãƒ¼ã‚ºé–‹å§‹ï¼‰ã€
  if (stage === "review"){
    freezeReviewBallsStart();
  } else {
    QUIZ_REVIEW_BALLS_FROZEN = false;
    QUIZ_REVIEW_FINALIZING = false;
  }

  showQuiz();
  syncDropletColorToGauge();

  setReviewVisualMode();

  primeNextQuestion();
  loadQuestion();
  closeStagePop();
}

/* âœ… é–¾å€¤ãƒã‚§ãƒƒã‚¯ä»˜ãã®å…¥å£ï¼ˆpre1/pre2ã®ã¿ï¼‰ */
async function startStage(stage){
  if (!_pendingLesson) return;
  if (stage === "pre2" && btnStagePre2.disabled) return;
  if (stage === "review" && btnStageReview.disabled) return;

  // âœ… pre1/pre2 ã¯å¸¸ã« lowRateãƒãƒƒãƒ—ã‚’è¡¨ç¤º
  if (stage === "pre1" || stage === "pre2"){
    await ensureLessonMetaForLowRate(_pendingLesson);
    const lesson = normLesson(_pendingLesson);
    const meta = _pendingLessonMeta || null;
    closeStagePop();
    await openLowRatePop(lesson, stage, meta);
    return;
  }

  // æ™®é€šã«é–‹å§‹
  startStageCore(stage, _pendingLessonMeta, _pendingLesson);
}

btnStagePre1.onclick = ()=> startStage("pre1");
btnStagePre2.onclick = ()=> startStage("pre2");
btnStageReview.onclick = ()=> startStage("review");

lessonListBox.addEventListener("pointerdown", (e)=>{
  if (stagePop.style.display === "block" && !stagePop.contains(e.target)){
    closeStagePop();
  }
}, { passive:true });

/* ========= ã‚¯ã‚¤ã‚º ========= */
const QT_MS = 4000;
let _qtRAF = null;
let _qtStart = 0;
let _qtActive = false;
let _questionShownAt = 0;

function initCircle(){
  const r = 18;
  const c = 2 * Math.PI * r;
  qTimerFg.style.strokeDasharray = String(c);
  qTimerFg.style.strokeDashoffset = "0";
  qTimerFg.dataset.circ = String(c);
}
initCircle();

function stopQuestionTimer(){
  _qtActive = false;
  if (_qtRAF) cancelAnimationFrame(_qtRAF);
  _qtRAF = null;
}
function startQuestionTimer(ms){
  stopQuestionTimer();
  _qtActive = true;
  _qtStart = performance.now();
  const circ = Number(qTimerFg.dataset.circ || "113.1");
  const tick = (now)=>{
    if (!_qtActive) return;
    const t = now - _qtStart;
    const p = Math.min(1, Math.max(0, t / ms));
    const off = circ * p;
    qTimerFg.style.strokeDashoffset = String(off);
    if (p >= 1){
      stopQuestionTimer();
      if (!ANSWERING) nextQuestionFast(true);
      return;
    }
    _qtRAF = requestAnimationFrame(tick);
  };
  _qtRAF = requestAnimationFrame(tick);
}

function clearOptions(){
  optGrid.innerHTML = "";
  if (quizResult) quizResult.textContent = "";
}
function setResult(msg, ok){
  if (!quizResult) return;
  quizResult.textContent = msg;
  quizResult.className = ok ? "muted ok" : "muted ng";
}

/* âœ… å…ˆèª­ã¿ */
let _prefetch = { promise:null, ctrl:null, key:"" };

function resetPrefetch(){
  if (_prefetch.ctrl){
    try{ _prefetch.ctrl.abort(); }catch(e){}
  }
  _prefetch = { promise:null, ctrl:null, key:"" };
}
function buildQKey(){
  return `${CURRENT.name}|${SELECTED_GRADE}|${CURRENT.lesson}|${CURRENT.stage}`;
}
function primeNextQuestion(){
  const key = buildQKey();
  if (_prefetch.promise && _prefetch.key === key) return;

  if (_prefetch.ctrl){
    try{ _prefetch.ctrl.abort(); }catch(e){}
  }
  const ctrl = new AbortController();
  _prefetch.ctrl = ctrl;
  _prefetch.key = key;

  _prefetch.promise = apiQuestion(CURRENT.name, SELECTED_GRADE, CURRENT.lesson, CURRENT.stage, ctrl.signal)
    .catch(()=>({ok:false,error:"prefetch_failed"}));
}

/* âœ… é‡è¤‡æ’é™¤ */
function canAskWordId(wordId){
  if (!SESSION) return true;
  const stats = getSessionWordStats(wordId);
  if (!stats || stats.achieved) return false;
  return (stats.shown || 0) < QUIZ_SESSION_RULES.unachievedMaxShows;
}

async function pickUniqueQuestion(forceFresh=false){
  const key = buildQKey();

  if (endSessionIfNeeded()){
    return { ok:false, error:"session_done" };
  }

  const triesMax = Math.max(1, QUIZ_RULES.uniqueFetchTriesPerPick|0);
  let last = null;

  for (let t=0; t<triesMax; t++){
    let j = null;

    if (!forceFresh && _prefetch.promise && _prefetch.key === key){
      j = await _prefetch.promise;
      const nextId = j && (j.word_id ?? j.wordId ?? j.id);
      const curId  = CURRENT.currentQ && CURRENT.currentQ.word_id;
      if (curId != null && nextId != null && String(nextId) === String(curId)){
        j = await apiQuestion(CURRENT.name, SELECTED_GRADE, CURRENT.lesson, CURRENT.stage);
      }
    } else {
      j = await apiQuestion(CURRENT.name, SELECTED_GRADE, CURRENT.lesson, CURRENT.stage);
    }

    last = j;
    resetPrefetch();
    primeNextQuestion();

    if (!j || !j.ok) return j || {ok:false,error:"unknown"};

    const wordId = j.word_id ?? j.wordId ?? j.id;
    if (!SESSION) return j;

    if (canAskWordId(wordId)){
      return j;
    }
    forceFresh = true;
  }

  return { ok:false, error:"no_more_unique", last };
}

async function nextQuestionFast(forceFresh=false){
  const j = await pickUniqueQuestion(forceFresh);
  renderQuestionJson(j);
}

function renderQuestionJson(j){
  clearOptions();
  quizWord.textContent = "";
  stopQuestionTimer();
  _questionShownAt = 0;
  syncDropletColorToGauge();
  setReviewVisualMode();

  if (j && (j.error === "session_done" || j.error === "no_more_unique")){
    clearOptions();
    quizWord.textContent = "ãŠã¤ã‹ã‚Œã•ã¾ï¼";
    quizExample.style.display = "none";

    stopQuestionTimer();

    // âœ… reviewã¯ã€Œæœ€å¾Œã®ç¬é–“ã«é”æˆç‡â†’ç‰è½ä¸‹ã€ã—ã¦ã‹ã‚‰ã€è½ä¸‹å®Œäº†+2ç§’ã§çµæœ
    if (CURRENT.stage === "review"){
      finalizeReviewBallsAndShowResult();
      return;
    }

    setTimeout(()=>openSessionResult(), 150);
    return;
  }

  if (!j || !j.ok){
    if (j && j.error === "choices_not_configured"){
      quizWord.textContent = j.word ? `ï¼ˆ${j.word}ï¼‰` : "";
      setResult("ã“ã®å˜èªã¯é¸æŠè‚¢ãŒä¸è¶³ï¼ˆæ­£è§£+èª¤ç­”1ä»¥ä¸Šï¼‰ã§ã™ã€‚", false);
      return;
    }
    setResult(`å•é¡Œå–å¾—å¤±æ•—ï¼š${(j && (j.error||j.message)) || "unknown"}`, false);
    return;
  }

  const wordId = j.word_id ?? j.wordId ?? j.id;
  const word = j.word ?? j.question ?? "";
  let options = Array.isArray(j.options) ? j.options : (Array.isArray(j.choices) ? j.choices : []);
  const correct = (j.correct != null) ? String(j.correct) : null;

  options = options.slice();
  if (QUIZ_RULES.shuffleChoices) shuffleInPlace(options);

const example = (j.example != null) ? String(j.example) : "";

CURRENT.currentQ = { raw:j, word_id: wordId, word, correct, example };
quizWord.textContent = word || "ï¼ˆno wordï¼‰";
markWordShown(wordId);
if (SESSION) SESSION.lastWordId = wordId;

if (SESSION && !SESSION.rewardPrepared && SESSION.asked === 1){
  defer(()=>{ prepareSessionReward().catch(()=>{}); });
}

// âœ… reviewã®ã¨ãï¼šæ”¹è¡Œã—ãªã„ï¼†è‡ªå‹•ç¸®å°ï¼†ä¾‹æ–‡è¡¨ç¤º
requestAnimationFrame(applyReviewPromptLayout);

  const st = j.stage || CURRENT.stage;
  if (stageBadge){
    stageBadge.style.display = "";
    stageBadge.textContent = stageLabel(st);
  }

  options.forEach(text=>{
    const b = document.createElement("button");
    b.className = "optBtn";
    b.type = "button";
    b.textContent = text;

    b.addEventListener("pointerdown", (ev)=>{
      ev.preventDefault();
      submitAnswer(text, b);
    }, { passive:false });

    b.addEventListener("click", ()=>{
      submitAnswer(text, b);
    });

    optGrid.appendChild(b);
  });

  requestAnimationFrame(applyReviewOptionLayout);
  _questionShownAt = performance.now();
  startQuestionTimer(QT_MS);
}

async function loadQuestion(){
  clearOptions();
  quizWord.textContent = "";
  stopQuestionTimer();

  resetPrefetch();
  primeNextQuestion();
  await nextQuestionFast(true);
}

let ANSWERING = false;

/* âœ… æŠ¼ã—ãŸç¬é–“ã«ç·‘/èµ¤ã¸ï¼ˆé€šä¿¡ã¯è£ã§ï¼‰ */
async function submitAnswer(text, chosenBtnEl){
  if (ANSWERING) return;
  if (!CURRENT.currentQ || !CURRENT.currentQ.word_id) return;
  if (sessionBack.style.display === "flex") return;

  ANSWERING = true;
  stopQuestionTimer();
  resetPrefetch();

  const btns = [...optGrid.querySelectorAll(".optBtn")];
  btns.forEach(b=>{
    b.disabled = true;
    b.classList.remove("pending","goodGreen","badRed","shake");
  });

  const correctLocal = (CURRENT.currentQ.correct != null) ? String(CURRENT.currentQ.correct) : null;
  const chosen = String(text);
  const answeredAt = performance.now();
  const isFastAnswer = _questionShownAt > 0 && ((answeredAt - _questionShownAt) <= QUIZ_SESSION_RULES.fastMs);

  // âœ… 1) å³ãƒ­ãƒ¼ã‚«ãƒ«åˆ¤å®šã§è‰²ã‚’ä»˜ã‘ã‚‹
  let isCorrectLocal = null;
  if (correctLocal != null){
    isCorrectLocal = (chosen === correctLocal);

    if (isCorrectLocal){
      btns.forEach(b=>{
        if (b.textContent === correctLocal) b.classList.add("goodGreen");
      });

      // âœ… reviewä¸­ã¯ğŸ’§ã‚’å‡ºã•ãªã„ï¼ˆé»’ä¸¸ã¯ã€Œæœ€å¾Œã ã‘è½ã¨ã™ã€ï¼‰
      if (CURRENT.stage !== "review"){
        spawnDroplets();
      }
    } else {
      let chosenBtn = null;
      btns.forEach(b=>{
        if (b.textContent === correctLocal) b.classList.add("goodGreen");
        if (b.textContent === chosen){
          b.classList.add("badRed");
          chosenBtn = b;
        }
      });
      if (chosenBtn){
        chosenBtn.classList.remove("shake");
        void chosenBtn.offsetWidth;
        chosenBtn.classList.add("shake");
      }
    }
  } else {
    if (chosenBtnEl) chosenBtnEl.classList.add("pending");
  }

  // âœ… 2) ã‚»ãƒƒã‚·ãƒ§ãƒ³é›†è¨ˆã‚‚â€œå³â€æ›´æ–°
  if (SESSION){
    SESSION.asked += 1;
    if (isCorrectLocal != null){
      applySessionAnswerStats({
        wordId: CURRENT.currentQ.word_id,
        word: CURRENT.currentQ.word || "",
        correctText: correctLocal || "",
        chosen,
        isCorrect: isCorrectLocal,
        isFast: isCorrectLocal ? isFastAnswer : false,
      });
    }
  }

  const snapshot = {
    name: CURRENT.name,
    grade: SELECTED_GRADE,
    lesson: CURRENT.lesson,
    stage: CURRENT.stage,
    word_id: CURRENT.currentQ.word_id,
    word: CURRENT.currentQ.word || "",
    correctLocal,
    chosen,
    isFastAnswer
  };

  const doneNow = endSessionIfNeeded();

  // âœ… 3) æ¬¡ã¸ï¼ˆreviewã®æœ€çµ‚ã ã‘ç‰¹æ®Šå‡¦ç†ï¼‰
  setTimeout(()=>{
    ANSWERING = false;
    if (doneNow){
      if (CURRENT.stage === "review"){
        finalizeReviewBallsAndShowResult();
      } else {
        openSessionResult();
      }
    } else {
      nextQuestionFast(true);
    }
  }, 260);

  // âœ… 4) DBä¿å­˜ + æœ€æ–°rateåæ˜ ï¼ˆè£ï¼‰
  (async ()=>{
    try{
      const j = await apiAnswer(snapshot.name, snapshot.word_id, snapshot.chosen);
      if (!j || !j.ok){
        defer(()=> setResult(`ä¿å­˜å¤±æ•—ï¼ˆèƒŒæ™¯å‡¦ç†ï¼‰ï¼š${(j && j.error) || "unknown"}`, false));
        return;
      }

      // correctLocalãŒå–ã‚Œãªã‹ã£ãŸå ´åˆã ã‘è£œæ­£
      if (SESSION && snapshot.correctLocal == null){
        const isCorrect = !!(j.is_correct ?? j.isCorrect ?? j.correct);
        applySessionAnswerStats({
          wordId: snapshot.word_id,
          word: snapshot.word,
          correctText: String(j.correct || ""),
          chosen: snapshot.chosen,
          isCorrect,
          isFast: isCorrect ? snapshot.isFastAnswer : false,
        });
      }

      // âœ… é€²æ—æ›´æ–°ã¯è£ã§ï¼ˆãŸã ã—reviewä¸­ã®é»’ç‰ã¯æ›´æ–°ã—ãªã„ï¼‰
      defer(async ()=>{
        try{
          const stillSame = (CURRENT.name === snapshot.name);
          if (!stillSame) return;
          await refreshLessons();
        }catch(e){}
      });
    }catch(e){
      defer(()=> setResult(`ä¿å­˜å¤±æ•—ï¼ˆèƒŒæ™¯å‡¦ç†ï¼‰ï¼š${(e && e.message) ? e.message : String(e)}`, false));
    }
  })();
}

btnNext.onclick = ()=>nextQuestionFast(true);

btnLessonComplete.onclick = async ()=>{
  if (!CURRENT.name || !CURRENT.lesson || !CURRENT.stage) return;
  const j = await apiLessonComplete(CURRENT.name, SELECTED_GRADE, CURRENT.lesson, CURRENT.stage);
  if (!j.ok){
    setStuStatus(`å®Œäº† å¤±æ•—ï¼š${j.error||"unknown"}`, false);
    return;
  }
  setStuStatus(`å®Œäº†OKï¼š${stageLabel(CURRENT.stage)}`, true);
  await refreshLessons();

  resetPrefetch();
  primeNextQuestion();
  nextQuestionFast(true);
};
btnBackLessons.onclick = async ()=>{ await showLessonList(); };

/* ========= å…¥å®¤ãƒ•ãƒ­ãƒ¼ ========= */
async function applyLastGradeFromMenu(){
  const m = await apiMenu(CURRENT.name);
  if (m.ok && m.last_grade != null){
    let g = Number(m.last_grade);
    if (!Number.isFinite(g)) g = 1;
    g = Math.trunc(g);
    SELECTED_GRADE = normalizeSelectedGrade(g);
    renderGradeButtons();
  }
}

let STARTING = false;
async function startFlow(){
  if (STARTING) return;
  STARTING = true;
  try{
    const selectedChara = getSavedChara();
    if (!selectedChara){ setStuStatus("ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚", false); return; }
    const name = normName(stuName.value);
    if (!name){ setStuStatus("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", false); return; }
    localStorage.setItem(NAME_KEY, name);


    STUDENT.studentKey = studentKeyFromName(name);

    setStuStatus("å…¥å®¤ä¸­â€¦", true);
    const j = await apiEnter(name);

    if (!j.ok){
      setStuStatus(`å…¥å®¤å¤±æ•—ï¼š${j.error||"unknown"}`, false);
      return;
    }

    CURRENT.name = normName(j.name || name);
    await applyLastGradeFromMenu();
    prefetchLessons();
    await loadAsa();
    await loadCharaItemPlacements();

    setStuStatus("å…¥å®¤OKï¼ˆèª²ã‚’æŠ¼ã—ã¦ã­ï¼‰", true);
    await showLessonList();
  } finally {
    STARTING = false;
  }
}
btnStart.onclick = startFlow;
stuName.addEventListener("keydown", (e)=>{ if (e.key === "Enter") startFlow(); });

/* ========= å°å½¢æç”»ï¼ˆå…ƒã®ã¾ã¾ + â€œä¼¸ã³â€ã‚¢ãƒ‹ãƒ¡å¯¾å¿œï¼‰ ========= */
let _resizeTick = null;
const _tileRefs = new Map();
let _waveRAF = null;

/* ===== âœ… èª²é¸æŠãƒãƒ¼ï¼šæˆ»ã£ãŸæ™‚ã«â€œä¼¸ã³ã‚‹â€ã‚¢ãƒ‹ãƒ¡ ===== */
let _levelAnimRAF = null;
const _lastLevelYMap = new Map(); // lessonKey -> å‰å›ã®levelYï¼ˆSVGåº§æ¨™ï¼‰

function stopLevelAnim(){
 

 if (_levelAnimRAF) cancelAnimationFrame(_levelAnimRAF);
  _levelAnimRAF = null;
}
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

function animateTileLevels(duration=650){
  stopLevelAnim();

  let need = false;
  _tileRefs.forEach(ref=>{
    if (Number.isFinite(ref.levelY) && Number.isFinite(ref.targetLevelY) && Math.abs(ref.targetLevelY - ref.levelY) > 0.5){
      need = true;
    }
  });

  if (!need){
    _tileRefs.forEach((ref, key)=>{
      if (Number.isFinite(ref.levelY)) _lastLevelYMap.set(key, ref.levelY);
    });
    return;
  }

  const t0 = performance.now();
  const starts = new Map();
  _tileRefs.forEach((ref, key)=> starts.set(key, ref.levelY));

  const tick = (now)=>{
    if (lessonListBox.style.display === "none"){ stopLevelAnim(); return; }

    const p = Math.min(1, (now - t0) / duration);
    const e = easeOutCubic(p);

    _tileRefs.forEach((ref, key)=>{
      const y0 = starts.get(key);
      const y1 = ref.targetLevelY;
      if (!Number.isFinite(y0) || !Number.isFinite(y1)) return;
      ref.levelY = y0 + (y1 - y0) * e;
      if (p >= 1) _lastLevelYMap.set(key, y1);
    });

    if (p < 1) _levelAnimRAF = requestAnimationFrame(tick);
    else stopLevelAnim();
  };

  _levelAnimRAF = requestAnimationFrame(tick);
}

function stopWaveLoop(){
  if (_waveRAF) cancelAnimationFrame(_waveRAF);
  _waveRAF = null;
  stopLevelAnim();
}

function makeWavePath(x, y, w, h, levelY, phase, amp, wavelength){
  const top = y;
  const bottom = y + h;

  const PAD = 3;
  levelY = clamp(levelY, top + PAD, bottom - PAD);

  const UP_FACTOR   = 0.28;
  const DOWN_FACTOR = 1.00;

  const upRoom = levelY - (top + PAD);
  const downRoom = (bottom - PAD) - levelY;

  const AmaxByUp = upRoom / UP_FACTOR;
  const AmaxByDown = downRoom / DOWN_FACTOR;

  let A = Math.min(amp, AmaxByUp, AmaxByDown);

  const MIN_A = 1.0;
  const minPossible = Math.min(AmaxByUp, AmaxByDown);
  if (minPossible > 0){
    A = Math.max(Math.min(MIN_A, minPossible), A);
  } else {
    A = 0;
  }

  const wl = Math.max(28, wavelength);
  const k = (2 * Math.PI) / wl;

  const steps = clamp(Math.round(w / (wl / 8)), 18, 60);
  const bias = A * 0.22;

  const pts = [];
  for (let i=0;i<=steps;i++){
    const xx = x + (w * i / steps);
    const s = Math.sin(k * (xx - x) + phase);
    const yy = levelY + s * A - bias;
    pts.push([xx, yy]);
  }

  let d = `M ${x} ${bottom} L ${x} ${levelY}`;
  d += ` L ${pts[0][0]} ${pts[0][1]}`;

  for (let i=1;i<pts.length;i++){
    const [x0,y0] = pts[i-1];
    const [x1,y1] = pts[i];
    const mx = (x0 + x1) / 2;
    const my = (y0 + y1) / 2;
    d += ` Q ${x0} ${y0} ${mx} ${my}`;
  }

  const last = pts[pts.length-1];
  d += ` T ${last[0]} ${last[1]}`;

  d += ` L ${x+w} ${bottom} Z`;
  return d;
}

function ensureWaveLoop(){
  if (_waveRAF) return;

  const frameMs = 1000 / Math.max(8, BG_ANIM_FPS_LESSON);
  let last = 0;

  const loop = (now)=>{
    if (lessonListBox.style.display === "none"){
      stopWaveLoop();
      return;
    }
    if ((now - last) < frameMs){
      _waveRAF = requestAnimationFrame(loop);
      return;
    }
    last = now;

    _tileRefs.forEach(ref=>{
      const { wavePath, waveBox, visRect } = ref;
      const levelY = ref.levelY;

      const bottom = waveBox.y + waveBox.h;

      if (visRect && Number.isFinite(levelY)){
        const h = Math.max(0, bottom - levelY);
        visRect.setAttribute("y", String(levelY));
        visRect.setAttribute("height", String(h));
      }

      const phase = now * 0.0032;
      const amp   = Math.max(0.7, waveBox.h * 0.018);
      const wl    = Math.max(42, waveBox.w * 0.80);

      wavePath.setAttribute(
        "d",
        makeWavePath(waveBox.x, waveBox.y, waveBox.w, waveBox.h, levelY, phase, amp, wl)
      );
    });

    _waveRAF = requestAnimationFrame(loop);
  };

  _waveRAF = requestAnimationFrame(loop);
}

/* =========================
   âœ… review(å¾©ç¿’) 10%ã”ã¨ã«é»’ä¸¸ã‚’æºœã‚ã‚‹ï¼ˆèª²é¸æŠå´ï¼‰
   â€»ã“ã“ã¯å…ƒã®ã¾ã¾
========================= */
let _reviewBallPrevCount = new Map();
let _reviewBallInitDone  = false;
let _reviewBallOffsets   = new Map();

function getReviewRate01(tile){
  const r = tile?.stageStats?.review?.rate;
  return (r != null) ? clamp(Number(r), 0, 1) : 0;
}
function getReviewBallCount(tile){
  const r = getReviewRate01(tile);
  return clamp(Math.floor(r * 10 + 1e-9), 0, 10);
}

/* ===== æ®µãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆrow0=4 / row1=4åºƒã’ã‚‹ / row2=3éš™é–“ / ä»¥é™=4ï¼‰===== */
function _normalizeCenters(centers, Ledge, Redge, r, minSep){
  centers = centers.slice().sort((a,b)=>a-b);
  const minX = Ledge + r;
  const maxX = Redge - r;

  centers[0] = clamp(centers[0], minX, maxX);
  for (let i=1;i<centers.length;i++){
    centers[i] = Math.max(centers[i], centers[i-1] + minSep);
  }

  const overflow = centers[centers.length-1] - maxX;
  if (overflow > 0){
    for (let i=0;i<centers.length;i++) centers[i] -= overflow;
  }

  const under = minX - centers[0];
  if (under > 0){
    for (let i=0;i<centers.length;i++) centers[i] += under;
  }

  for (let i=0;i<centers.length;i++){
    centers[i] = clamp(centers[i], minX, maxX);
  }
  return centers;
}

function buildBallLayoutInTrapezoid(trap, r, offBox){
  const {x1,y1,x2,y2,x3,y3,x4,y4} = trap;
  const bottomY = y4;
  const topY    = y1;

  const pad = Math.max(2.5, r * 0.6);
  const minGapY = Math.max(1.2, r * 0.30);
  const stepY = (2*r + minGapY);

  function lerp(a,b,t){ return a + (b-a)*t; }
  function leftXAt(y){
    const t = (y - y1) / (y4 - y1 || 1);
    return lerp(x1, x4, clamp(t,0,1));
  }
  function rightXAt(y){
    const t = (y - y2) / (y3 - y2 || 1);
    return lerp(x2, x3, clamp(t,0,1));
  }

  function colsForRow(row){
    if (row === 2) return 3;
    return 4;
  }

  offBox._layoutSig = offBox._layoutSig || "v2_4-4-3_safe";
  if (offBox._layoutSig !== "v2_4-4-3_safe"){
    for (const k of Object.keys(offBox)) delete offBox[k];
    offBox._layoutSig = "v2_4-4-3_safe";
  }

  offBox._rows = offBox._rows || {};

  const rows = [];
  const slotsFlat = [];
  let row = 0;

  for (;; row++){
    const cy = bottomY - pad - r - row * stepY;
    if (cy < topY + pad + r) break;

    const Ledge = leftXAt(cy)  + pad;
    const Redge = rightXAt(cy) - pad;

    const cols = colsForRow(row);
    const minGapX = Math.max(1.2, r * 0.30);
    const minSep = 2*r + minGapX;

    const avail = Redge - Ledge;
    const needed = cols * (2*r) + (cols-1) * minGapX;
    if (!(avail >= needed)) continue;

    let centers = offBox._rows[row];

    if (!Array.isArray(centers) || centers.length !== cols){
      if (row === 2){
        const below = offBox._rows[1];
        if (Array.isArray(below) && below.length === 4){
          const m01 = (below[0] + below[1]) / 2;
          const m12 = (below[1] + below[2]) / 2;
          const m23 = (below[2] + below[3]) / 2;
          centers = [m01, m12, m23];

          const jitter = r * 0.18;
          centers = centers.map(v => v + (Math.random()*2 - 1) * jitter);

          centers = _normalizeCenters(centers, Ledge, Redge, r, minSep);
        } else {
          const slack = Math.max(0, avail - needed);
          const weights = Array.from({length: cols+1}, ()=> (Math.random()+0.18));
          const sumW = weights.reduce((a,b)=>a+b,0);
          const extra = weights.map(w => (w/sumW) * slack);

          let x = Ledge + extra[0] + r;
          centers = [];
          for (let c=0;c<cols;c++){
            centers.push(x);
            if (c<cols-1) x += (2*r) + minGapX + extra[c+1];
          }
          centers = _normalizeCenters(centers, Ledge, Redge, r, minSep);
        }
      } else {
        const slack = Math.max(0, avail - needed);
        const weights = Array.from({length: cols+1}, ()=> (Math.random()+0.18));
        const sumW = weights.reduce((a,b)=>a+b,0);
        const extra = weights.map(w => (w/sumW) * slack);

        let x = Ledge + extra[0] + r;
        centers = [];
        for (let c=0;c<cols;c++){
          centers.push(x);
          if (c<cols-1) x += (2*r) + minGapX + extra[c+1];
        }
        centers = _normalizeCenters(centers, Ledge, Redge, r, minSep);

        if (row === 1){
          const mid = (centers[0] + centers[centers.length-1]) / 2;
          const spread = 1.28;
          centers = centers.map(v => mid + (v - mid) * spread);
          centers = _normalizeCenters(centers, Ledge, Redge, r, minSep);
        }
      }

      offBox._rows[row] = centers;
    }

    rows.push({ row, cols, cy, Ledge, Redge, minGapX });

    for (let col=0; col<cols; col++){
      const cx = centers[col];
      slotsFlat.push({ cx, cy, row, col, cols, Ledge, Redge, minGapX });
    }
  }

  return { rows, slotsFlat };
}

function _findRowByBallIndex(bi, layout){
  let acc = 0;
  for (const rinfo of layout.rows){
    const cols = rinfo.cols;
    if (bi < acc + cols){
      return { row: rinfo.row, within: bi - acc, cols };
    }
    acc += cols;
  }
  return null;
}

function pickSlotForBallIndex(bi, layout, offBox){
  const pos = _findRowByBallIndex(bi, layout);
  if (!pos) return null;

  const { row, within, cols } = pos;
  const rowSlots = layout.slotsFlat.filter(s => s.row === row);
  if (!rowSlots.length) return null;

  offBox._rowOrder = offBox._rowOrder || {};

  if (!offBox._rowOrder[row]){
    if (cols === 4){
      const outer = (Math.random() < 0.5) ? [0,3] : [3,0];
      const inner = (Math.random() < 0.5) ? [1,2] : [2,1];
      offBox._rowOrder[row] = outer.concat(inner);
    } else if (cols === 3){
      const sides = (Math.random() < 0.5) ? [0,2] : [2,0];
      offBox._rowOrder[row] = [1].concat(sides);
    } else {
      offBox._rowOrder[row] = Array.from({length: cols}, (_,i)=>i);
    }
  }

  const col = offBox._rowOrder[row][within] ?? within;
  return rowSlots.find(s => s.col === col) || rowSlots[within] || null;
}

/* ===== å°å½¢æç”»ï¼ˆç•¥ï¼šå…ƒã®ã¾ã¾ï¼‰ ===== */
function drawLessonTrapezoids(animateLevels=true){
  if (!lessonSvg) return;
  if (lessonListBox.style.display === "none") return;

  const rect = lessonList.getBoundingClientRect();
  const W = Math.max(1, Math.floor(rect.width));
  const H = Math.max(1, Math.floor(rect.height));

  lessonSvg.setAttribute("viewBox", `0 0 ${W} ${H}`);
  lessonSvg.innerHTML = "";
  _tileRefs.clear();

  const tiles = _lastLessonTiles || [];
  if (tiles.length === 0) return;

  const lineCount = 3;
  const base = {
    marginX: 20,
    lineH: 12,
    trapTopW: 96,
    trapBottomW: 62,
    trapH: 112,
    trapGapX: 18,
    strokeW: 2
  };
  const strokeColor = "transparent";
  const lineColor = "#000";
  const shapeStroke = "#B3B3B3";
  const padY = 160;

  const marginX = base.marginX;
  const lineW = Math.max(0, W - marginX * 2);
  const perLine = 3;

  const maxShow = lineCount * perLine;
  const shown = tiles.slice(0, maxShow);

  const firstLineY = padY;
  const lastLineY  = Math.max(firstLineY, H - padY);
  const lineGapY   = (lineCount <= 1) ? 0 : (lastLineY - firstLineY) / (lineCount - 1);

  const trapTopW = base.trapTopW;
  const trapBottomW = base.trapBottomW;
  const trapH = base.trapH;

  function computeGap(rowCount){
    if (rowCount <= 1) return 0;
    const raw = (lineW - rowCount * trapTopW) / (rowCount - 1);
    return clamp(raw, 8, base.trapGapX);
  }

  const defs = sEl("defs");
  lessonSvg.appendChild(defs);
  const handFilter = sEl("filter");
  handFilter.setAttribute("id", "handDrawnStroke");
  handFilter.setAttribute("x", "-12%");
  handFilter.setAttribute("y", "-12%");
  handFilter.setAttribute("width", "124%");
  handFilter.setAttribute("height", "124%");

  const handTurb = sEl("feTurbulence");
  handTurb.setAttribute("type", "fractalNoise");
  handTurb.setAttribute("baseFrequency", "0.9");
  handTurb.setAttribute("numOctaves", "1");
  handTurb.setAttribute("seed", "2");
  handTurb.setAttribute("result", "noise");
  handFilter.appendChild(handTurb);

  const handDisp = sEl("feDisplacementMap");
  handDisp.setAttribute("in", "SourceGraphic");
  handDisp.setAttribute("in2", "noise");
  handDisp.setAttribute("scale", "0.7");
  handDisp.setAttribute("xChannelSelector", "R");
  handDisp.setAttribute("yChannelSelector", "G");
  handFilter.appendChild(handDisp);

  defs.appendChild(handFilter);


  const GAUGE_MAX = 0.90;

  for (let i = 0; i < lineCount; i++) {
    const lineY = Math.max(0, firstLineY + i * lineGapY);



    const line = sEl("rect");
    line.setAttribute("x", marginX);
    line.setAttribute("y", lineY);
    line.setAttribute("width", lineW);
    line.setAttribute("height", base.lineH);
    line.setAttribute("fill", lineColor);
    lessonSvg.appendChild(line);

    const startIdx = i * perLine;
    const endIdx = Math.min(shown.length, startIdx + perLine);
    const rowCount = endIdx - startIdx;
    if (rowCount <= 0) continue;

    const trapGapX = computeGap(rowCount);
    const totalTrapW = rowCount * trapTopW + (rowCount - 1) * trapGapX;
    const startX = marginX + Math.max(0, (lineW - totalTrapW) / 2);

    for (let j = 0; j < rowCount; j++) {
      const t = shown[startIdx + j];
      const lessonKey = normLesson(t.lesson);

      const cx = startX + j * (trapTopW + trapGapX) + trapTopW / 2;

      const bottomY = lineY;
      const topMargin = 24;
      const safeTrapH = Math.min(trapH, Math.max(10, bottomY - topMargin));
      const topY = bottomY - safeTrapH;

      const x1 = cx - trapTopW/2,  y1 = topY;
      const x2 = cx + trapTopW/2,  y2 = topY;
      const x3 = cx + trapBottomW/2, y3 = bottomY;
      const x4 = cx - trapBottomW/2, y4 = bottomY;
      const points = `${x1},${y1} ${x2},${y2} ${x3},${y3} ${x4},${y4}`;

      const hit = sEl("polygon");
      hit.setAttribute("points", points);
      hit.setAttribute("fill", "transparent");
      hit.style.cursor = "pointer";
      hit.addEventListener("click", (ev)=>{
        const listRect = lessonList.getBoundingClientRect();
        const clientX = ev.clientX;
        const clientY = ev.clientY;
        let lx, ly;
        if (typeof clientX === "number" && typeof clientY === "number"){
          lx = clientX - listRect.left;
          ly = clientY - listRect.top;
        } else {
          lx = cx;
          ly = bottomY + 8;
        }
        openStagePop(lessonKey, t, lx, ly + 10);
        ev.stopPropagation();
      });
      lessonSvg.appendChild(hit);

      const trapClipId = `trapclip_${i}_${j}`;
      const trapClip = sEl("clipPath");
      trapClip.setAttribute("id", trapClipId);
      const trapClipPoly = sEl("polygon");
      trapClipPoly.setAttribute("points", points);
      trapClip.appendChild(trapClipPoly);
      defs.appendChild(trapClip);

      const waveBox = { x:x1, y:topY, w:(x2-x1), h:safeTrapH };

      let rate = Number(t.achieveRate);
      if (!Number.isFinite(rate)) rate = 0;
      rate = clamp(rate, 0, 1);
      const hasGauge = rate > 0;

      const levelYTarget_raw = bottomY - (waveBox.h * (GAUGE_MAX * rate));
      const LEVEL_PAD = 2;
      const levelYTarget = clamp(levelYTarget_raw, topY + LEVEL_PAD, bottomY - LEVEL_PAD);

      let levelYStart = levelYTarget;
      if (animateLevels){
        const prev = _lastLevelYMap.get(lessonKey);
        if (Number.isFinite(prev)){
          levelYStart = clamp(prev, topY + LEVEL_PAD, bottomY - LEVEL_PAD);
        }
      }

      const visY = levelYStart;
      const visH = bottomY - levelYStart;

      const visClipId = `visclip_${i}_${j}`;
      const visClip = sEl("clipPath");
      visClip.setAttribute("id", visClipId);
      const visRect = sEl("rect");
      visRect.setAttribute("x", waveBox.x - 2);
      visRect.setAttribute("y", visY);
      visRect.setAttribute("width", waveBox.w + 4);
      visRect.setAttribute("height", visH);
      visClip.appendChild(visRect);
      defs.appendChild(visClip);



      const wavePath = sEl("path");
      const fill = getGaugeFill(CURRENT.name, SELECTED_GRADE, lessonKey) || "#111";
      wavePath.setAttribute("fill", fill);
      wavePath.setAttribute("opacity", String(GAUGE_ALPHA));
      wavePath.setAttribute("clip-path", `url(#${visClipId})`);
      wavePath.style.pointerEvents = "none";
      if (hasGauge){
        const gWave = sEl("g");
        gWave.setAttribute("clip-path", `url(#${trapClipId})`);
        lessonSvg.appendChild(gWave);
        gWave.appendChild(wavePath);
      }

      /* âœ… reviewé»’ä¸¸ï¼ˆå°å½¢å†…ï¼‰ */
      const ballCount = getReviewBallCount(t);
      const prevCount = _reviewBallPrevCount.get(lessonKey) ?? 0;

      const ballR = clamp(trapTopW * 0.050, 3.8, 6.5);

      const gBalls = sEl("g");
      gBalls.setAttribute("clip-path", `url(#${trapClipId})`);
      gBalls.style.pointerEvents = "none";
      lessonSvg.appendChild(gBalls);

      const offKey = `${CURRENT.name}|${SELECTED_GRADE}|${lessonKey}`;
      const offBox = _reviewBallOffsets.get(offKey) || {};
      _reviewBallOffsets.set(offKey, offBox);

      const layout = buildBallLayoutInTrapezoid({x1,y1,x2,y2,x3,y3,x4,y4}, ballR, offBox);
      const slotsFlat = layout.slotsFlat;

      const maxBalls = Math.min(ballCount, slotsFlat.length);

      for (let bi=0; bi<maxBalls; bi++){
        const slot = pickSlotForBallIndex(bi, layout, offBox);
        if (!slot) continue;

        const bcx = slot.cx;
        const bcy = slot.cy;

        if (!offBox[bi]){
          const startScatter = Math.max(ballR * 2.3, slot.minGapX + ballR * 1.8);
          const startDX = (Math.random()*2 - 1) * startScatter;

          const safe = Math.min(ballR * 0.18, slot.minGapX * 0.18);
          let sign = 0;
          if (slot.cols === 3){
            if (slot.col === 1) sign = 0;
            else sign = (slot.col === 0) ? -1 : 1;
          } else {
            sign = (slot.col % 2 === 0) ? -1 : 1;
          }
          const rollTry = sign * safe * (0.65 + Math.random()*0.25);
          const rollDX = rollTry;

          const dropFrom = -(safeTrapH + 70 + Math.random() * 130);

          offBox[bi] = {
            landDX: 0,
            startDX,
            dropFrom,
            rollDX,
            rollMid: rollDX * 0.35
          };
        }

        const off = offBox[bi];
        const isNew = (_reviewBallInitDone && animateLevels && (ballCount > prevCount) && (bi >= prevCount));

        const c = sEl("circle");
        c.setAttribute("cx", bcx);
        c.setAttribute("cy", bcy);
        c.setAttribute("r",  ballR);

        if (isNew){
          c.setAttribute("class", "reviewBall drop");
          c.style.setProperty("--dropFrom", `${off.dropFrom}px`);
          c.style.setProperty("--startDX",  `${off.startDX.toFixed(2)}px`);
          c.style.setProperty("--landDX",   `0px`);
          c.style.setProperty("--rollDX",   `${off.rollDX.toFixed(2)}px`);
          c.style.setProperty("--rollMid",  `${off.rollMid.toFixed(2)}px`);
          c.style.animationDelay = `${(bi - prevCount) * 70}ms`;
        } else {
          c.setAttribute("class", "reviewBall");
          c.style.transform = `translate(${Number(off.rollDX||0).toFixed(2)}px, 0px)`;
        }

        gBalls.appendChild(c);
      }

      _reviewBallPrevCount.set(lessonKey, ballCount);

      _tileRefs.set(lessonKey, {
        wavePath,
        waveBox,
        visRect,
        levelY: levelYStart,
        targetLevelY: levelYTarget
      });

      const CUP_SCALE = 1.33;
      const cupW = trapTopW * CUP_SCALE;
      const cupH = safeTrapH * CUP_SCALE;
      const cupX = cx - cupW / 2;
      const cupY = topY - (cupH - safeTrapH) / 2 - (safeTrapH * 0.03);

      const cup = sEl("image");
      cup.setAttribute("href", "cup.png");
      cup.setAttribute("x", cupX);
      cup.setAttribute("y", cupY);
      cup.setAttribute("width", cupW);
      cup.setAttribute("height", cupH);
      cup.setAttribute("preserveAspectRatio", "xMidYMid meet");
      cup.style.pointerEvents = "none";
      lessonSvg.appendChild(cup);


      const imgW = trapTopW * 0.65;
      const imgH = safeTrapH * 0.7;
      const imgX = cx - imgW / 2;
      const imgY = topY + (safeTrapH - imgH) * 0.40;

      const img = sEl("image");
      img.setAttribute("href", "kame.png");
      img.setAttribute("x", imgX);
      img.setAttribute("y", imgY);
      img.setAttribute("width", imgW);
      img.setAttribute("height", imgH);
      img.setAttribute("preserveAspectRatio", "xMidYMid meet");
      img.setAttribute("clip-path", `url(#${trapClipId})`);
      img.setAttribute("opacity", "0.55");
      img.style.pointerEvents = "none";
      lessonSvg.appendChild(img);


      const labelY = topY + safeTrapH*0.47;
      const label = sEl("text");
      label.setAttribute("x", cx);
      label.setAttribute("y", labelY);
      label.setAttribute("text-anchor", "middle");
      label.setAttribute("dominant-baseline", "middle");
      label.setAttribute("font-size", 17);
      label.setAttribute("font-weight", "900");
      label.setAttribute("fill", "#111");
      label.style.pointerEvents = "none";
      label.textContent = lessonKey;
      lessonSvg.appendChild(label);

      // =========================
      // âœ… 100%ã«ãªã£ãŸã‚‰ã€Œä¸Šã®å††ã‚’èµ¤ã€ã«ã™ã‚‹ï¼ˆç„¡ã‘ã‚Œã°è¿½åŠ ï¼‰
      // ã•ã‚‰ã«ï¼š100%æ™‚ã ã‘ kame2 + èµ¤ã„ä¸‰è§’ã‚‚è¡¨ç¤º
      // =========================
      const isFull = (rate >= 0.999);

      const FULL_RING_WIDTH_SCALE = 1.1;
      const rxRing = (trapTopW / 2) * FULL_RING_WIDTH_SCALE;
      const ryRing = Math.max(6, base.lineH * 0.65);
      const RING_SHIFT_Y = 8;

      const cxRing = cx;
      const cyRing = (topY) - ryRing + RING_SHIFT_Y;
      const RING_FILL = "#ff0000";
      const RING_STROKE = "#BC3825";
      const RING_STROKE_W = Math.max(1, Math.round(base.strokeW * 1));


      if (isFull){
        const ring = sEl("ellipse");
        ring.setAttribute("cx", cxRing);
        ring.setAttribute("cy", cyRing);
        ring.setAttribute("rx", rxRing);
        ring.setAttribute("ry", ryRing);
        ring.setAttribute("fill", RING_FILL);
        ring.setAttribute("stroke", RING_STROKE);
        ring.setAttribute("stroke-width", RING_STROKE_W);
        ring.setAttribute("filter", "url(#handDrawnStroke)");
        ring.style.pointerEvents = "none";
        lessonSvg.appendChild(ring);

        // ãƒªãƒ³ã‚°å†…ã‚¯ãƒªãƒƒãƒ—
        const ringClipId = `ringclip_${i}_${j}`;
        const ringClip = sEl("clipPath");
        ringClip.setAttribute("id", ringClipId);

        const ringClipEl = sEl("ellipse");
        ringClipEl.setAttribute("cx", cxRing);
        ringClipEl.setAttribute("cy", cyRing);
        ringClipEl.setAttribute("rx", rxRing - 1.2);
        ringClipEl.setAttribute("ry", ryRing - 1.2);
        ringClip.appendChild(ringClipEl);
        defs.appendChild(ringClip);

        // kame2ï¼ˆã‚µã‚¤ã‚º/ä½ç½®ã¯ã“ã“ã ã‘ã§èª¿æ•´å¯ï¼‰
        const KAME2 = { scale: 0.72, dx: 0, dy: 0 };

        const w2 = (rxRing * 2 - 2.4) * clamp(KAME2.scale, 0.1, 2.0);
        const h2 = (ryRing * 2 - 2.4) * clamp(KAME2.scale, 0.1, 2.0);

        const k2 = sEl("image");
        k2.setAttribute("href", "kame2.png");
        k2.setAttribute("x", cxRing - w2/2 + (KAME2.dx || 0));
        k2.setAttribute("y", cyRing - h2/2 + (KAME2.dy || 0));
        k2.setAttribute("width", w2);
        k2.setAttribute("height", h2);
        k2.setAttribute("preserveAspectRatio", "xMidYMid meet");
        k2.setAttribute("clip-path", `url(#${ringClipId})`);
        k2.style.pointerEvents = "none";
        lessonSvg.appendChild(k2);

        // ä¸‰è§’ï¼ˆã‚µã‚¤ã‚º/ä½ç½®ã¯ã“ã“ã ã‘ã§èª¿æ•´å¯ï¼‰
        const TRI = {
          dx: -(rxRing - 73) + 6,
          dy: 7,
          scale: 0.6,
          rot: -69,
          tipShift: 0.00,
          tipUp:    0.00,
          baseSpread: 1.30,
          baseSkew:   0.00,
          round: 1.6,
        };

        const GAP = 10;
        const side = Math.max(10, ryRing * 2.25) * clamp(TRI.scale, 0.2, 3);
        const hTri = side * Math.sqrt(3) / 2;

        const baseCxTri = cxRing - rxRing - GAP - hTri/2;
        const baseCyTri = cyRing;

        const cxTri = baseCxTri + (TRI.dx ?? 0);
        const cyTri = baseCyTri + (TRI.dy ?? 0);

        const tipX = cxTri - hTri/2 + (TRI.tipShift ?? 0);
        const tipY = cyTri + (TRI.tipUp ?? 0);

        const baseX = cxTri + hTri/2;
        const spread = clamp(TRI.baseSpread ?? 1, 0.3, 2.2);
        const skew = (TRI.baseSkew ?? 0);

        const p2x = baseX;
        const p2y = cyTri - (side/2) * spread - skew;
        const p3x = baseX;
        const p3y = cyTri + (side/2) * spread + skew;

        const tri = sEl("path");
        tri.setAttribute("d", `M ${tipX} ${tipY} L ${p2x} ${p2y} L ${p3x} ${p3y} Z`);
        tri.setAttribute("fill", RING_FILL);

        const sw = Math.max(2, side * clamp(TRI.round ?? 0.12, 0.02, 0.30));
        tri.setAttribute("stroke", RING_FILL);
        tri.setAttribute("stroke-width", String(sw));
        tri.setAttribute("stroke-linejoin", "round");
        tri.setAttribute("stroke-linecap", "round");
        tri.style.paintOrder = "stroke fill";
        tri.style.pointerEvents = "none";

        const rot = Number(TRI.rot || 0);
        if (rot){
          tri.setAttribute("transform", `rotate(${rot} ${cxTri} ${cyTri})`);
        }
        lessonSvg.appendChild(tri);
      }
    }
  }

  ensureWaveLoop();

  if (animateLevels) animateTileLevels(650);
  else {
    _tileRefs.forEach((ref, key)=>{
      ref.levelY = ref.targetLevelY;
      if (Number.isFinite(ref.levelY)) _lastLevelYMap.set(key, ref.levelY);
    });
  }

  _reviewBallInitDone = true;
}

function scheduleLessonRedraw(){
  if (_resizeTick) cancelAnimationFrame(_resizeTick);
  _resizeTick = requestAnimationFrame(()=>drawLessonTrapezoids(false));
}
window.addEventListener("resize", scheduleLessonRedraw);
window.addEventListener("resize", scheduleCharaItemsRender);
window.addEventListener("resize", ()=>requestAnimationFrame(applyReviewOptionLayout));


/* ========= â˜… ã‚¯ã‚¤ã‚ºå…¨ä½“ï¼špre1+pre2 æ³¢ã‚²ãƒ¼ã‚¸ ========= */
function getCurrentLessonSumRate01(){
  const lesson = normLesson(CURRENT.lesson);
  if (!lesson) return 0;

  const t = (_lastLessonTiles || []).find(x => normLesson(x.lesson) === lesson);
  if (!t || !t.stageStats) return 0;

  const r = t.stageStats.sum_pre1_pre2?.rate;
  return (r != null) ? clamp(r, 0, 1) : 0;
}

let _quizWave = null;
let _quizWaveRAF = null;
let _quizWaveState = { W:0, H:0, levelY:0, phase:0, amp:0, wl:0 };
let _quizRateVis = 0;

function buildQuizWaveSvg(){
  if (!quizProgressSvg) return;

  quizProgressSvg.innerHTML = "";
  quizProgressSvg.setAttribute("viewBox", "0 0 100 100");

  const wavePath = sEl("path");
  const fill = getGaugeFill(CURRENT.name, SELECTED_GRADE, CURRENT.lesson) || "#000";
  wavePath.setAttribute("fill", fill);
  wavePath.setAttribute("opacity", String(GAUGE_ALPHA));
  wavePath.style.pointerEvents = "none";
  quizProgressSvg.appendChild(wavePath);

  _quizWave = { wavePath };
  syncDropletColorToGauge();
}

function stopQuizWaveLoop(){
  if (_quizWaveRAF) cancelAnimationFrame(_quizWaveRAF);
  _quizWaveRAF = null;
}

function startQuizWaveLoop(){
  if (_quizWaveRAF) return;

  if (!_quizWave) buildQuizWaveSvg();
  if (!_quizWave) return;

  _quizRateVis = clamp(getCurrentLessonSumRate01(), 0, 1);
  const frameMs = 1000 / Math.max(8, BG_ANIM_FPS_QUIZ);
  let last = 0;

  const loop = (now)=>{
    if (!quizBox || quizBox.style.display === "none"){
      stopQuizWaveLoop();
      return;
    }

    if ((now - last) < frameMs){
      _quizWaveRAF = requestAnimationFrame(loop);
      return;
    }
    last = now;

    const rect = quizProgressSvg.getBoundingClientRect();
    const W = Math.max(1, Math.floor(rect.width));
    const H = Math.max(1, Math.floor(rect.height));
    quizProgressSvg.setAttribute("viewBox", `0 0 ${W} ${H}`);

    const fill = getGaugeFill(CURRENT.name, SELECTED_GRADE, CURRENT.lesson) || "#000";
    _quizWave.wavePath.setAttribute("fill", fill);
    _quizWave.wavePath.setAttribute("opacity", String(GAUGE_ALPHA));

    syncDropletColorToGauge();

    const rateRaw = getCurrentLessonSumRate01();
    _quizRateVis += (rateRaw - _quizRateVis) * 0.10;

    const GAUGE_MAX = 0.92;
    const levelY = H - (H * (GAUGE_MAX * _quizRateVis));

    const amp = Math.max(0.8, H * 0.010);
    const wl  = Math.max(80,  W * 0.65);
    const phase = now * 0.0032;

    _quizWaveState = { W, H, levelY, phase, amp, wl };

    _quizWave.wavePath.setAttribute(
      "d",
      makeWavePath(0, 0, W, H, levelY, phase, amp, wl)
    );

    _quizWaveRAF = requestAnimationFrame(loop);
  };

  _quizWaveRAF = requestAnimationFrame(loop);
}

/* =========================
   âœ… æ­£è§£ã—ãšãï¼ˆ3æ»´ï¼‰ç”Ÿæˆï¼šCSSã®ã¿
========================= */
function spawnDroplets(){
  if (!dropletLayer) return;

  syncDropletColorToGauge();

  const kids = dropletLayer.querySelectorAll(".droplet");
  if (kids.length > 18) dropletLayer.innerHTML = "";

  const stageH = (dropletLayer.getBoundingClientRect().height) || (_quizWaveState.H || 0);
  const fromY = -90;
  const toY   = Math.max(180, stageH + 120);

  function makeOne(delayMs){
    setTimeout(()=>{
      const d = document.createElement("div");
      d.className = "droplet";
      d.style.setProperty("--fromY", `${fromY}px`);
      d.style.setProperty("--toY", `${toY}px`);
      d.style.setProperty("--dur", `${980 + Math.random()*420}ms`);
      d.style.animationDelay = `${Math.max(0, delayMs)}ms`;
      d.addEventListener("animationend", ()=> d.remove(), { once:true });
      dropletLayer.appendChild(d);
    }, 0);
  }

  makeOne(0);
  makeOne(220);
  makeOne(440);
}

/* =========================
   âœ… reviewã‚¯ã‚¤ã‚ºï¼š10%ã”ã¨ã«é»’ä¸¸ï¼ˆç”»é¢ä¸‹ã«æºœã‚ã‚‹ï¼‰
========================= */
const _quizReviewBallOffsets = new Map();
const _quizReviewBallPrev    = new Map();

function _tileByLesson(lesson){
  lesson = normLesson(lesson);
  return (_lastLessonTiles || []).find(x => normLesson(x.lesson) === lesson) || null;
}
function getReviewRate01ForLesson(lesson){
  const t = _tileByLesson(lesson);
  const r = t?.stageStats?.review?.rate;
  return (r != null) ? clamp(Number(r), 0, 1) : 0;
}
function getReviewBallCountForLesson(lesson){
  const r = getReviewRate01ForLesson(lesson);
  return clamp(Math.floor(r * 10 + 1e-9), 0, 10);
}
function setReviewVisualMode(){
  const isReview = (CURRENT.stage === "review");
  if (dropletLayer) dropletLayer.style.display = isReview ? "none" : "";
  if (reviewBallSvg) reviewBallSvg.style.display = isReview ? "" : "none";
}

function _getQuizBallLayout(){
  const stageRect = quizStage.getBoundingClientRect();

  const W = Math.max(1, Math.floor(stageRect.width));
  const H = Math.max(1, Math.floor(stageRect.height));

  const padX = Math.max(16, W * 0.06);
  const gapX = Math.max(10, W * 0.03);

  const avail = (W - padX * 2 - gapX * 3);
  let r = (avail / 4) / 2;
  r = r * 0.92;
  r = clamp(r, 14, 44);

  const gapY  = Math.max(8, r * 0.30);
  const stepY = 2 * r + gapY;

  const bottomPad = Math.max(12, r * 0.35);
  const baseY = (H - bottomPad - r);

  const centersX = [];
  for (let i=0;i<4;i++){
    centersX.push(padX + r + i * (2*r + gapX));
  }

  return { W, H, ballR:r, gapY, stepY, baseY, centersX, gapX };
}

function renderQuizReviewBalls(lesson, animateFromPrev=false, prevCount=0){
  if (!reviewBallSvg) return;
  if (CURRENT.stage !== "review") return;

  const key = `${CURRENT.name}|${SELECTED_GRADE}|${normLesson(lesson)}`;
  const count = getReviewBallCountForLesson(lesson);

  const stageRect = quizStage.getBoundingClientRect();
  const W = Math.max(1, Math.floor(stageRect.width));
  const H = Math.max(1, Math.floor(stageRect.height));
  reviewBallSvg.setAttribute("viewBox", `0 0 ${W} ${H}`);
  reviewBallSvg.innerHTML = "";

  const layout = _getQuizBallLayout();
  const { ballR, stepY, baseY, centersX, gapX } = layout;

  const offBox = _quizReviewBallOffsets.get(key) || {};
  _quizReviewBallOffsets.set(key, offBox);

  const max = Math.max(0, Math.min(count, 60));
  for (let i=0; i<max; i++){
    const row = Math.floor(i / 4);
    const col = i % 4;

    const cx = centersX[col];
    const cy = baseY - row * stepY;

    if (!offBox[i]){
      const startDX = (Math.random()*2 - 1) * (ballR * 2.2);

      const safe = Math.min(ballR * 0.18, gapX * 0.18);
      const sign = (col % 2 === 0) ? -1 : 1;
      const rollDX = sign * safe * (0.70 + Math.random()*0.20);

      const dropFrom = -(H + 140 + Math.random() * 260);

      offBox[i] = {
        startDX,
        rollDX,
        rollMid: rollDX * 0.35,
        dropFrom
      };
    }

    const off = offBox[i];
    const isNew = (animateFromPrev && (i >= prevCount));

    const c = sEl("circle");
    c.setAttribute("cx", cx);
    c.setAttribute("cy", cy);
    c.setAttribute("r",  ballR);

    if (isNew){
      c.setAttribute("class", "reviewBall drop");
      c.style.setProperty("--dropFrom", `${off.dropFrom}px`);
      c.style.setProperty("--startDX",  `${off.startDX.toFixed(2)}px`);
      c.style.setProperty("--landDX",   `0px`);
      c.style.setProperty("--rollDX",   `${off.rollDX.toFixed(2)}px`);
      c.style.setProperty("--rollMid",  `${off.rollMid.toFixed(2)}px`);
      c.style.animationDelay = `${(i - prevCount) * 90}ms`;
    } else {
      c.setAttribute("class", "reviewBall");
      c.style.transform = `translate(${Number(off.rollDX||0).toFixed(2)}px, 0px)`;
    }

    reviewBallSvg.appendChild(c);
  }

  _quizReviewBallPrev.set(key, count);
}


/* ========= åˆæœŸåŒ– ========= */
await loadGradeSettings();
const initialLoads = [
  loadItemClasses(),
  loadCharaSlots({ render:false }),
  loadInitialItems({ render:false })
];
if (savedName){
  initialLoads.push(loadCharaItemPlacements());
}
await Promise.all(initialLoads);
preloadCharaImages();
preloadLessonAssets();
renderCharaSelectButtons();
renderCharaItems();
updateCharaSelectPreview();
showNameScreen();
syncDropletColorToGauge();
</script>
</body>
</html>